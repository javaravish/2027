<!DOCTYPE html>
<html lang="en">
<head>
    <title>JPA</title>

    <!-- Stylesheet -->
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="spring">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">☰</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="#">Spring</a>
        <span class="separator">/</span>
        <a href="#">JPA</a>
    </div>
</nav>
<!-- Components will be inserted here by components.js -->

<!-- Main Content Section -->
<main id="content">
    <h3>1. ORM (Object-Relational Mapping):</h3>
    <ul>
        <li>A technique to connect object-oriented Java applications with relational databases.</li>
        <li>Allows performing database operations (CRUD) in an object-oriented manner (save object, update object,
            etc.).
        </li>
    </ul>

    <h3>1. Advantages of JPA:</h3>
    <ul>
        <li><strong>Database Independent</strong>: Code works across different databases (requires changing dialect).
        </li>
        <li><strong>Easy Development</strong>: Queries are often generated automatically; custom queries can be written
            using JPQL (Java Persistence Query Language) or HQL (Hibernate Query Language), which use class/variable
            names instead of table/column names.
        </li>
        <li><strong>Data Type Independence</strong>: Handles mapping between Java and database data types.</li>
    </ul>

    <h3>1. Spring Data JPA Repositories:</h3>
    <ul>
        <li>Provides predefined interfaces (<strong>CrudRepository</strong>, <strong>PagingAndSortingRepository</strong>,
            <strong>JpaRepository</strong>) to simplify database operations.
        </li>
        <li>Programmers extend these interfaces, and Spring Data JPA automatically generates implementation classes at
            runtime for common CRUD operations.
        </li>
        <li>JpaRepository is the most commonly used, extending the others.</li>
    </ul>

    <h3>1. Predefined Methods in Repository Interfaces:</h3>
    <ul>
        <li>save(), delete(), findById(), findAll(), count(), existsById(), findAll(Sort), findAll(Pageable).</li>
    </ul>

    <h3>1. Entity Class and Common Annotations:</h3>
    <p>A Java class mapped to a database table.</p>
    <p>@Entity: Maps the class to a table (must-have).</p>
    <p>@Table: (Optional) Specifies table details.</p>
    <p>@Id: Marks the primary key field (must-have).</p>
    <p>@Column: (Optional) Specifies column details.</p>
    <p>@GeneratedValue: For auto-generating ID values.</p>

    <h3>1. Naming Convention for Finder Methods (Spring Data JPA):</h3>
    <p>Custom query methods are automatically derived from method names following a pattern: findBy&lt;VariableName&gt;&lt;keyword&gt;.</p>
    <p>Example: findByLastName(String lastName) generates a WHERE clause based on the lastName variable.</p>

    <h3>1. Creating a Custom Repository:</h3>
    <p>Create an interface that extends Repository, CrudRepository, PagingAndSortingRepository, or JpaRepository.</p>
    <p>JpaRepository is generally preferred for relational databases.</p>

    <h3>1. @Query Annotation:</h3>
    <p>A native query lets you write plain SQL (specific to your database) instead of JPQL (Java Persistence Query
        Language). This is useful when:</p>
    <p>You need database-specific features</p>
    <p>You want better performance for complex queries</p>
    <p>You can't express something easily using JPQL</p>

    <p>• Non-Select Operations: For UPDATE or DELETE queries, @Query must be combined with @Modifying.</p>

    <pre class="java-code">
<code>
public interface UserRepository extends JpaRepository<User, Long> {
    // 1. Simple Native Query with Positional Parameter
    @Query(value = "SELECT * FROM users WHERE email = ?1", nativeQuery = true)
    User findByEmail(String email);
    // 2. Using Named Parameters
    @Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
    List<User> findByName(@Param("name") String name);
    // 3. Custom Result Set (select specific columns)
    @Query(value = "SELECT id, name FROM users WHERE age > :age", nativeQuery = true)
    List<Object[]> findIdAndNameByAgeGreaterThan(@Param("age") int age);
    // 4. Update query using @Modifying
    @Modifying
    @Transactional
    @Query(value = "UPDATE users SET name = :name WHERE id = :id", nativeQuery = true)
    int updateUserName(@Param("id") Long id, @Param("name") String name);
}
</code>
</pre>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Point</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>nativeQuery = true</td>
                <td>Must be specified for row SQL</td>
            </tr>
            <tr>
                <td>Column names</td>
                <td>Must match DB column names exactly</td>
            </tr>
            <tr>
                <td>Result</td>
                <td>Can map to entity or Object[]</td>
            </tr>
            <tr>
                <td>@Modifying</td>
                <td>Required for UPDATE , DELETE queries</td>
            </tr>
            <tr>
                <td>@Transactional</td>
                <td>Required for write operations</td>
            </tr>
            <tr>
                <td>Pagination</td>
                <td>Use countQuery along with value if paginating</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>1. Collections Mapping Supported by JPA:</h3>
    <p>• List, Set, Map, Collection.</p>
    <p>• Requires @ElementCollection annotation over the collection variable.</p>
    <p>• Creates a child table:</p>
    <p>• Set: Two columns (foreign key, element data).</p>
    <p>• List/Map: Three columns (foreign key, index/key, element data).</p>

    <h3>1. Enabling Spring Data JPA:</h3>
    <ul>
        <li>Auto-configured by adding spring-boot-starter-data-ipa dependency.</li>
        <li>Requires database connection and JPA details in application.properties</li>
        <li>(e.g., spring.datasource.*, spring.ipa.hibernate.ddl-auto, spring.ipa.show-sql,
            spring.ipa.database-platform).
        </li>
    </ul>

    <p>comparison between Spring Data's CrudRepository , JpaRepository , and PagingAndSortingRepository :</p>

    <h3>1. CrudRepository</h3>
    <ul>
        <li>Basic operations for CRUD (Create, Read, Update, Delete).</li>
        <li>Parent interface for other repos.</li>
        <li>Methods:
            <ul>
                <li>save(), saveAll(), findById(), findAll(), findAllById(), existsById(),</li>
                <li>count(), delete(), deleteById(), deleteAll()</li>
            </ul>
        </li>
        <li>No pagination or sorting support.</li>
    </ul>

    <h3>2. PagingAndSortingRepository (extends CrudRepository )</h3>
    <ul>
        <li>Adds pagination & sorting support.</li>
        <li>Methods:
            <ul>
                <li>findAll(Sort sort) // Sorting</li>
                <li>findAll(Pageable pageable) // Pagination + Sorting</li>
            </ul>
        </li>
        <li>Used when you need large dataset handling with pages.</li>
    </ul>

    <h3>3. JpaRepository (extends PagingAndSortingRepository )</h3>
    <ul>
        <li>Most feature-rich (includes all methods from CrudRepository + PagingAndSortingRepository ).</li>
        <li>Adds batch operations & JPA-specific methods.</li>
        <li>Methods:
            <ul>
                <li>flush(), saveAndFlush(), deleteInBatch(), deleteAllInBatch(), getOne()</li>
            </ul>
        </li>
        <li>Also provides findAll() with Sort/Pageable.</li>
        <li>Best for JPA/Hibernate projects.</li>
    </ul>

    <h3>Key Differences Summary</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Feature</th>
                <th>CrudRepository</th>
                <th>PagingAndSortingRepository</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Basic CRUD</td>
                <td>Yes</td>
                <td>Yes (inherits)</td>
            </tr>
            <tr>
                <td>Pagination</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Sorting</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            </tbody>
        </table>
    </div>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Batch Operations</th>
                <th>✗ No</th>
                <th>✗ No</th>
                <th>✓ Yes ( deleteInBatch() )</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>JPA-Specific Methods</td>
                <td>✗ No</td>
                <td>✗ No</td>
                <td>✓ Yes ( flush(), getOne() )</td>
            </tr>
            <tr>
                <td>Best For</td>
                <td>Simple CRUD</td>
                <td>Large datasets with pagination</td>
                <td>Full JPA/Hibernate projects</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>When to Use Which?</h3>
    <ul>
        <li><strong>CrudRepository</strong> → Simple CRUD operations (no pagination/sorting needed).</li>
        <li><strong>PagingAndSortingRepository</strong> → When dealing with large datasets requiring pagination/sorting.
        </li>
        <li><strong>JpaRepository</strong> → When using JPA/Hibernate and need advanced features (batch ops, flush(),
            etc.).
        </li>
    </ul>

    <h3>1. Spring Transactions</h3>
    <p>A database transaction is a sequence of actions that are treated as a single unit of work. These actions should
        either complete entirely or take no effect at all. Transaction management is an important part of RDBMS-oriented
        enterprise application to ensure data integrity and consistency. The concept of transactions can be described
        with the following four key properties described as <strong>ACID</strong></p>

    <h3>1. ACID Properties</h3>
    <ul>
        <li><strong>Atomicity</strong> → A transaction should be treated as a single unit of operation, which means
            either the entire sequence of operations is successful or unsuccessful.
        </li>
        <li><strong>Consistency</strong> → This represents the consistency of the referential integrity of the database,
            unique primary keys in tables, etc.
        </li>
        <li><strong>Isolation</strong> → There may be many transaction processing with the same data set at the same
            time. Each transaction should be isolated from others to prevent data corruption.
        </li>
        <li><strong>Durability</strong> → Once a transaction has completed, the results of this transaction have to be
            made permanent and cannot be erased from the database due to system failure.
        </li>
    </ul>

    <h3>2. Transaction Isolation Levels</h3>
    <p>Transaction isolation level is a concept that is not exclusive to the Spring framework. It is applied to
        transactions in general and is directly related with the ACID transaction properties. Isolation level defines
        how the changes made to some data repository by one transaction affect other simultaneous concurrent
        transactions, and also how and when that changed data becomes available to other transactions. When we define a
        transaction using the Spring framework we are also able to configure in which isolation level that same
        transaction will be executed.</p>

    <h4>Usage example</h4>
    <p>Using the @Transactional annotation we can define the isolation level of a Spring managed bean transactional
        method. This means that the transaction in which this method is executed will run with that isolation level:</p>

    <ul>
        <li><strong>Dirty Read</strong> – A Dirty read is a situation when a transaction reads data that has not yet
            been committed. For example, Let's say transaction 1 updates a row and leaves it uncommitted, meanwhile,
            Transaction 2 reads the updated row. If transaction 1 rolls back the change, transaction 2 will have read
            data that is considered never to have existed.
        </li>
        <li><strong>Non Repeatable read</strong> – Non Repeatable read occurs when a transaction reads the same row
            twice and gets a different value each time. For example, suppose transaction T1 reads data. Due to
            concurrency, another transaction T2 updates the same data and commit, Now if transaction T1 rereads the same
            data, it will retrieve a different value.
        </li>
        <li><strong>Phantom Read</strong> – Phantom Read occurs when two same queries are executed, but the rows
            retrieved by the two, are different. For example, suppose transaction T1 retrieves a set of rows that
            satisfy some search criteria. Now, Transaction T2 generates some new rows that match the search criteria for
            transaction T1. If transaction T1 re-executes the statement that reads the rows, it gets a different set of
            rows this time.
        </li>
        <li><strong>ISOLATION_READ_UNCOMMITTED</strong> – Allows to read changes that haven't yet been committed. It
            suffer from <strong>Dirty reads</strong>, <strong>Nonrepeatable read and Phantom read</strong>.
        </li>
    </ul>

    <pre class="java-code">
<code>
@Transactional(isolation = Isolation.READ_UNCOMMITTED)
public Account getAccount(int id) {
    return accountRepository.findById(id).get();
}
</code>
</pre>

    <ul>
        <li><strong>ISOLATION_READ_COMMITTED</strong> – Allows reads from concurrent transactions that have been
            committed. It may suffer from <strong>Nonrepeatable read and Phantom read</strong> Because other
            transactions may be updating the data.
        </li>
    </ul>

    <pre class="java-code">
<code>
@Transactional(isolation = Isolation.READ_COMMITTED)
public Account getAccount(int id) {
    return accountRepository.findById(id).get();
}
</code>
</pre>

    <ul>
        <li><strong>ISOLATION_REPEATABLE_READ</strong> – Multiple reads of the same field will yield the same results
            until it is changed by itself. It may suffer from <strong>Phantom read</strong> Because other transactions
            may be inserting the data.
        </li>
    </ul>

    <pre class="java-code">
<code>
@Transactional(isolation = Isolation.REPEATABLE_READ)
public void checkBalance(int id) {
    Account accl = accountRepository.findById(id).get();
    // some other transaction modifies it in the meantime
    Account acc2 = accountRepository.findById(id).get();
    // accl == acc2 is guaranteed
}
</code>
</pre>

    <ul>
        <li><strong>ISOLATION_SERIALIZABLE</strong> – SERIALIZABLE isolation level is the most restrictive of all
            isolation levels. Transactions are executed with locking at all levels (read, range and write locking) so
            they appear as if they were executed in a serialized way. This leads to a scenario where none of the issues
            mentioned above may occur, but in the other way we don't allow transaction concurrency and consequently
            introduce a performance penalty.
        </li>
    </ul>

    <pre class="java-code">
<code>
@Transactional(isolation = Isolation.SERIALIZABLE)
public List<Account> getAccountsAboveBalance(double amount) {
    return accountRepository.findByBalanceGreaterThan(amount);
}
</code>
</pre>

    <p>To summarize, the existing relationship between isolation level and read phenomena may be expressed in the
        following table :</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Isolation Level</th>
                <th>Dirty Read</th>
                <th>Non Repeatable Read</th>
                <th>Phantom Read</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>READ_UNCOMMITTED</td>
                <td>Yes</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>READ_COMMITTED</td>
                <td>No</td>
                <td>Yes</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>REPEATABLE_READ</td>
                <td>No</td>
                <td>No</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>SERIALIZABLE</td>
                <td>No</td>
                <td>No</td>
                <td>No</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>2. Transaction Propagation Levels</h3>
    <p>Propagation level in spring decides if the spring has to create a new transaction or the same transaction can be
        used to perform a database operation. Transaction Propagation Types: There are seven types of Transaction
        Propagation:</p>
    <p>REQUIRED is Default Transaction Propagation.</p>
    <ul>
        <li>REQUIRED</li>
        <li>REQUIRES_NEW</li>
        <li>NESTED</li>
        <li>SUPPORTS</li>
        <li>NOT_SUPPORTED</li>
        <li>NEVER</li>
        <li>MANDATORY</li>
    </ul>

    <h3>1. REQUIRED</h3>
    <p>Spring REQUIRED behavior means that the same transaction will be used if there is an already opened transaction
        in the current bean method execution context. If there is no existing transaction the Spring container will
        create a new one. If multiple methods configured as REQUIRED behavior are called in a nested way they will be
        assigned distinct logical transactions but they will all share the same physical transaction. In short this
        means that if an inner method causes a transaction to rollback, the outer method will fail to commit and will
        also rollback the transaction.</p>
    <p>Note that the inner method throws a RuntimeException and is annotated with REQUIRED behavior. This means that it
        will use the same transaction as the outer bean, so the outer transaction will fail to commit and will also
        rollback.</p>
    <p><strong>Note:</strong> The only exceptions that set a transaction to rollback state by default are the unchecked
        exceptions (likeRuntimeException). If you want checked exceptions to also set transactions to rollback you must
        configure them to do so.</p>

    <pre class="java-code">
<code>
@Transactional(propagation = Propagation.REQUIRED)
public void methodB() {
    // Joins caller's transaction
}
</code>
</pre>

    <h3>2. REQUIRES_NEW</h3>
    <p>behavior means that a new physical transaction will always be created by the container. In other words the inner
        transaction may commit or rollback independently of the outer transaction, i.e. the outer transaction will not
        be affected by the inner transaction result: they will run in <strong>distinct physical transactions</strong>.
    </p>
    <p>The inner method is annotated with REQUIRES_NEW and throws a RuntimeException so it will set its transaction to
        rollback but will not affect the outer transaction. The outer transaction is paused when the inner transaction
        starts and then resumes after the inner transaction is Concluded. They run independently of each other so the
        outer transaction may commit successfully.</p>

    <h3>3. NESTED</h3>
    <p>The NESTED behavior makes nested Spring transactions to use the same physical transaction but sets savepoints
        between nested invocations so inner transactions may also rollback independently of outer transactions. This may
        be familiar to JDBC aware developers as the savepoints are achieved with JDBC savepoints, so this behavior
        should only be used with Spring JDBC managed transactions.</p>

    <h3>4. SUPPORTS</h3>
    <p>The SUPPORTS behavior will execute in the scope of a transaction if an opened transaction already exists. If
        there isn't an already opened transaction the method will execute anyway but in a non-transactional way.</p>

    <h3>5. NOT_SUPPORTED</h3>
    <p>The NOT_SUPPORTED behavior The NOT_SUPPORTED behavior will execute outside of the scope of any transaction. If an
        opened transaction already exists it will be paused.</p>

    <h3>6. NEVER</h3>
    <p>The NEVER behavior states that an existing opened transaction must not already exist. If a transaction exists an
        exception will be thrown by the container.</p>

    <h3>7. MANDATORY</h3>
    <p>The MANDATORY behavior states that an existing opened transaction must already exist. If not an exception will be
        thrown by the container.</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Propagation</th>
                <th>Behavior</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>REQUIRED</td>
                <td>Always executes in a transaction. If there is any existing transaction it uses it. If none exists
                    then only a new one is created
                </td>
            </tr>
            <tr>
                <td>SUPPORTS</td>
                <td>It may or may not run in a transaction. If current transaction exists then it is supported. If none
                    exists then gets executed with out transaction.
                </td>
            </tr>
            <tr>
                <td>NOT_SUPPORTED</td>
                <td>Always executes without a transaction. If there is any existing transaction it gets suspended</td>
            </tr>
            <tr>
                <td>REQUIRES_NEW</td>
                <td>Always executes in a new transaction. If there is any existing transaction it gets suspended</td>
            </tr>
            <tr>
                <td>NEVER</td>
                <td>Always executes with out any transaction. It throws an exception if there is an existing
                    transaction
                </td>
            </tr>
            <tr>
                <td>MANDATORY</td>
                <td>Always executes in a transaction. If there is any existing transaction it is used. If there is no
                    existing transaction it will throw an exception.
                </td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>3. Cascade Types JPA</h3>
    <p>Cascade in JPA means automatically propagating operations (like persist, merge, delete) from a parent entity to
        its associated child entities.</p>
    <p>For example:</p>
    <p>• When you save a Department , it can automatically save all its Employee objects.</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Cascade Type</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>PERSIST</td>
                <td>Propagates persist() to child (Saving new parent and children)</td>
            </tr>
            <tr>
                <td>MERGE</td>
                <td>Propagates merge() to child (Updating entire object graph)</td>
            </tr>
            <tr>
                <td>REMOVE</td>
                <td>Propagates remove() (delete) to child (Deleting parent and its children)</td>
            </tr>
            <tr>
                <td>REFRESH</td>
                <td>Refreshes child from database (Complete sync with DB)</td>
            </tr>
            <tr>
                <td>DETACH</td>
                <td>Detaches child from persistence context (Unloading from persistence unit)</td>
            </tr>
            <tr>
                <td>ALL</td>
                <td>Applies all above cascade types (All of the above)</td>
            </tr>
            </tbody>
        </table>
    </div>

    <pre class="java-code">
<code>
@OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
private List<Employee> employees;
</code>
</pre>

    <h3>1. CascadeType.PERSIST</h3>

    <pre class="java-code">
<code>
Department dept = new Department();
dept.setName("IT");

Employee emp1 = new Employee();
emp1.setName("Ravi");
emp1.setDepartment(dept);

dept.getEmployees().add(emp1);

entityManager.persist(dept); // Will also persist emp1
</code>
</pre>

    <p>• Without cascade, this would throw an error unless you also explicitly call persist(emp1).</p>

    <h3>2. CascadeType.MERGE</h3>
    <p>Used when updating an existing parent and its children.</p>

    <pre class="java-code">
<code>
dept.setName("IT - Update!");
emp1.setName("Ravi k");

entityManager.merge(dept); // Werges both dept and emp1
</code>
</pre>

    <h3>3. CascadeType.REMOVE</h3>

    <pre class="java-code">
<code>
entityManager.remove(dept); // Will also remove all employees under this dept
</code>
</pre>

    <p>△ Be careful: deleting parent will delete all associated children.</p>

    <h3>4. CascadeType.REFRESH</h3>
    <p>Reloads entity from the database and applies changes to children too.</p>

    <pre class="java-code">
<code>
entityManager.refresh(dept); // Employees will also be refreshed
</code>
</pre>

    <h3>5. CascadeType.DETACH</h3>
    <p>Removes entity and its children from the persistence context.</p>

    <pre class="java-code">
<code>
entityManager.detach(dept); // Employees will also be detached
</code>
</pre>

    <h3>6. CascadeType.ALL</h3>
    <p>Shortcut for:</p>
    <p>CascadeType.PERSIST, MERGE, RENOVE, REFRESH, DETACH</p>
    <p>Common for @OneToMany and @OneToOne relationships.</p>

    <h3>4. What is @Repository ?</h3>
    <p>@Repository is a Spring stereotype annotation used to indicate that the class is a DAO (Data Access Object) — a
        component responsible for interacting with the database.</p>
    <p>It is part of Spring's Component Scanning mechanism and also adds persistence-related exception translation.
        (DataAccessException )</p>
    <p>You use @Repository :</p>
    <p>• In the persistence (DAO) layer</p>
    <p>• On classes that directly interact with the database</p>
    <p>• In combination with Spring JPA, JDBC, Hibernate, etc.</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Reason</th>
                <th>Explanation</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Component Scanning</td>
                <td>Spring auto-detects and registers it as a Bean</td>
            </tr>
            <tr>
                <td>Exception Translation</td>
                <td>Converts JDBC/Hibernate exceptions into Spring's DataAccessException</td>
            </tr>
            <tr>
                <td>Semantic Clarity</td>
                <td>Makes the code cleaner, separates responsibilities</td>
            </tr>
            <tr>
                <td>Integration with Spring Data</td>
                <td>Required for using JpaRepository , CrudRepository ,etc.</td>
            </tr>
            </tbody>
        </table>
    </div>

    <p>📌 Exception Translation Example</p>
    <p>Spring wraps SQL-related exceptions into unchecked exceptions like:</p>

    <pre class="java-code">
<code>
try {
    // JDBC code
} catch(SQLException ex) {
    throw new DataAccessException(ex);
}
</code>
</pre>

    <p>This happens only if the class is marked with @Repository .</p>

    <h3>How to Use @Repository</h3>

    <h3>1. Plain JDBC Repository</h3>

    <pre class="java-code">
<code>
@Repository
public class UserDao {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public User findById(int id) {
        return jdbcTemplate.queryForObject("SELECT * FROM user WHERE id = ?", new Object[]{id}, new UserRowMapper());
    }
}
</code>
</pre>

    <h3>2. Spring Data JPA Repository</h3>

    <pre class="java-code">
<code>
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
}
</code>
</pre>

    <p>In Spring Data, @Repository is optional because Spring auto-adds it to interfaces extending JpaRepository , but
        you can add it explicitly for clarity or exception translation.</p>

    <h3>Best Practices</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Practice</th>
                <th>Why?</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Always annotate DAO classes</td>
                <td>Enables exception translation</td>
            </tr>
            <tr>
                <td>Use interface + implementation</td>
                <td>Better for unit testing & flexibility</td>
            </tr>
            <tr>
                <td>Keep repository logic thin</td>
                <td>Business logic belongs in services</td>
            </tr>
            <tr>
                <td>Don't annotate @Service as @Repository</td>
                <td>Layers should be separated</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>Summary</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Feature</th>
                <th>@Repository</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Role</td>
                <td>Marks DAO/data-access class</td>
            </tr>
            <tr>
                <td>Spring Bean?</td>
                <td>Yes, registered via scanning</td>
            </tr>
            <tr>
                <td>Exception Translation</td>
                <td>Yes</td>
            </tr>
            <tr>
                <td>Required for JPA Repos?</td>
                <td>Optional (auto-added), but useful</td>
            </tr>
            <tr>
                <td>Layer</td>
                <td>Persistence Layer</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>5. JPA Relationships (Entity Associations)</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Relationship Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>One-to-One</td>
                <td>One entity has exactly one related entity</td>
                <td>Person → Passport</td>
            </tr>
            <tr>
                <td>One-to-Many</td>
                <td>One entity has many related entities</td>
                <td>Department → Employees</td>
            </tr>
            <tr>
                <td>Many-to-One</td>
                <td>Many entities link to one entity</td>
                <td>Employees → Department</td>
            </tr>
            <tr>
                <td>Many-to-Many</td>
                <td>Many entities on both sides</td>
                <td>Student → Course</td>
            </tr>
            </tbody>
        </table>
    </div>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Type</th>
                <th>Cardinality</th>
                <th>Annotations</th>
                <th>Table Structure</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>One-to-One</td>
                <td>1 → 1</td>
                <td>@OneToOne, @JoinColumn</td>
                <td>FK in either table</td>
            </tr>
            <tr>
                <td>One-to-Many</td>
                <td>1 → many</td>
                <td>@OneToMany, mappedBy</td>
                <td>FK in child table</td>
            </tr>
            <tr>
                <td>Many-to-One</td>
                <td>many → 1</td>
                <td>@ManyToOne, @JoinColumn</td>
                <td>FK in many side</td>
            </tr>
            <tr>
                <td>Many-to-Many</td>
                <td>many → many</td>
                <td>@ManyToMany, @JoinTable</td>
                <td>Extra join table</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>1. One-to-One Relationship</h3>
    <p>Example: User → UserProfile</p>

    <pre class="java-code">
<code>
@Entity
public class User {
    @Id @GenerateValue
    private Long id;
    private String name;

    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id")
    private UserProfile profile;
}

@Entity
public class UserProfile {
    @Id @GenerateValue
    private Long id;
    private String address;
}
</code>
</pre>

    <p>● @JoinColumn specifies the foreign key for owning side table only</p>
    <p>● specifies the foreign key column used to join two tables in a unidirectional or owning side of bidirectional
        relationships.</p>
    <p>● prevents the creation of a join table in bidirectional mapping.(On inverse side (non-owning in
        bidirectional))</p>

    <h3>2. One-to-Many Relationship</h3>
    <p>Example: Department → Employees</p>

    <pre class="java-code">
<code>
@Entity
public class Department {
    @Id @GenerateValue
    private Long id;
    private String name;

    @OneToMany(mappedBy = "department", cascade = CascadeType.ALL)
    private List<Employee> employees;
}

@Entity
public class Employee {
    @Id @GenerateValue
    private Long id;
    private String name;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}
</code>
</pre>

    <p>● mappedBy is used to avoid creating a join table</p>
    <p>● Avoid CascadeType.REMOVE on the child side (may delete parent)</p>

    <h3>3. Many-to-One Relationship</h3>
    <p>Inverse of One-to-Many.</p>

    <pre class="java-code">
<code>
@ManyToOne
@JoinColumn(name = "dept_id")
private Department department;
</code>
</pre>

    <p>✔ Automatically handled when One-to-Many is properly mapped.</p>

    <h3>4. Many-to-Many Relationship</h3>
    <p>Example: Student → Course</p>

    <pre class="java-code">
<code>
@Entity
public class Student {
    @Id @GenerateValue
    private Long id;
    private String name;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}

@Entity
public class Course {
    @Id @GenerateValue
    private Long id;
    private String name;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}
</code>
</pre>

    <p>● @JoinTable is optional (default join table name: student_courses)</p>
    <p>● mappedBy is required on one side to avoid duplicate mapping</p>

    <h3>5. Bidirectional vs Unidirectional</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Type</th>
                <th>Description</th>
                <th>Example</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Unidirectional</td>
                <td>Navigation only from one side</td>
                <td>User → Profile (User can access Profile, but not vice versa)</td>
            </tr>
            <tr>
                <td>Bidirectional</td>
                <td>Navigation from both sides</td>
                <td>Department ↔ Employee (Both can access each other)</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>6. Lazy vs Eager Loading</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Loading Type</th>
                <th>Fetch Type</th>
                <th>Behavior</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Lazy</td>
                <td>FetchType.LAZY</td>
                <td>Loads related entities only when accessed</td>
            </tr>
            <tr>
                <td>Eager</td>
                <td>FetchType.EAGER</td>
                <td>Loads related entities immediately with parent</td>
            </tr>
            </tbody>
        </table>
    </div>

    <p>● Default: One-to-Many, Many-to-Many → LAZY</p>
    <p>● Default: Many-to-One, One-to-One → EAGER</p>

    <h3>7. Common Issues & Solutions</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Issue</th>
                <th>Solution</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>N+1 Query Problem</td>
                <td>Use JOIN FETCH or EntityGraph</td>
            </tr>
            <tr>
                <td>Multiple Bags Exception</td>
                <td>Use Set instead of List for multiple collections</td>
            </tr>
            <tr>
                <td>LazyInitializationException</td>
                <td>Use @Transactional or fetch in same session</td>
            </tr>
            <tr>
                <td>Circular References</td>
                <td>Use @JsonIgnore or DTOs</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>8. Best Practices</h3>
    <ul>
        <li>Use LAZY loading by default</li>
        <li>Avoid CascadeType.ALL unless necessary</li>
        <li>Use bidirectional mapping only when needed</li>
        <li>Always set mappedBy to avoid extra join tables</li>
        <li>Use DTOs to avoid exposing entities directly</li>
    </ul>

    <h3>6. JPA Entity Lifecycle</h3>
    <p>JPA entities go through different states during their lifecycle. Understanding these states is crucial for
        effective persistence management.</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>State</th>
                <th>Description</th>
                <th>Managed by</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>New/Transient</td>
                <td>Entity is created but not associated with persistence context</td>
                <td>Not managed</td>
            </tr>
            <tr>
                <td>Managed/Persistent</td>
                <td>Entity is associated with persistence context and tracked</td>
                <td>EntityManager</td>
            </tr>
            <tr>
                <td>Detached</td>
                <td>Entity was managed but is no longer associated</td>
                <td>Not managed</td>
            </tr>
            <tr>
                <td>Removed</td>
                <td>Entity is scheduled for deletion from database</td>
                <td>EntityManager</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>1. New/Transient State</h3>
    <p>An object is in the transient state if it's:</p>
    <p>• Just instantiated using the new operator</p>
    <p>• Not associated with any persistence context</p>
    <p>• Not mapped to any database row</p>

    <pre class="java-code">
<code>
Employee emp = new Employee(); // Transient state
emp.setName("John");
</code>
</pre>

    <h3>2. Managed/Persistent State</h3>
    <p>An entity enters the managed state when:</p>
    <p>• It's saved using entityManager.persist()</p>
    <p>• Retrieved from the database using entityManager.find()</p>
    <p>• It's associated with the current persistence context</p>
    <p>• Changes are automatically tracked and synchronized with the database</p>

    <pre class="java-code">
<code>
entityManager.persist(emp); // Now in managed state
emp.setName("John Doe"); // Change will be automatically persisted
</code>
</pre>

    <h3>3. Detached State</h3>
    <p>An entity becomes detached when:</p>
    <p>• The persistence context is closed (entityManager.close())</p>
    <p>• The entity is explicitly detached (entityManager.detach(entity))</p>
    <p>• The persistence context is cleared (entityManager.clear())</p>
    <p>• Changes are no longer automatically tracked</p>

    <pre class="java-code">
<code>
entityManager.close(); // All entities become detached
// OR
entityManager.detach(emp); // Specific entity detached
emp.setName("John Smith"); // Change won't be persisted
</code>
</pre>

    <h3>4. Removed State</h3>
    <p>An entity enters the removed state when:</p>
    <p>• entityManager.remove(entity) is called</p>
    <p>• It's scheduled for deletion from the database</p>
    <p>• The deletion occurs when the transaction is committed</p>

    <pre class="java-code">
<code>
entityManager.remove(emp); // Now in removed state
// Will be deleted from database on commit
</code>
</pre>

    <h3>5. State Transition Methods</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Method</th>
                <th>From State</th>
                <th>To State</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>persist()</td>
                <td>Transient</td>
                <td>Managed</td>
            </tr>
            <tr>
                <td>find()</td>
                <td>N/A</td>
                <td>Managed</td>
            </tr>
            <tr>
                <td>merge()</td>
                <td>Detached</td>
                <td>Managed</td>
            </tr>
            <tr>
                <td>remove()</td>
                <td>Managed</td>
                <td>Removed</td>
            </tr>
            <tr>
                <td>detach()</td>
                <td>Managed</td>
                <td>Detached</td>
            </tr>
            <tr>
                <td>close()</td>
                <td>Managed</td>
                <td>Detached</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>6. Checking Entity State</h3>
    <p>You can check if an entity is managed using:</p>

    <pre class="java-code">
<code>
boolean isManaged = entityManager.contains(entity);
</code>
</pre>

    <h3>7. Reattaching Detached Entities</h3>
    <p>To bring a detached entity back to managed state:</p>

    <pre class="java-code">
<code>
// Method 1: Using merge()
Employee managedEmp = entityManager.merge(detachedEmp);

// Method 2: Using refresh() (if you have the ID)
Employee emp = entityManager.find(Employee.class, id);
entityManager.refresh(emp); // Reloads from database
</code>
</pre>

    <h3>8. Lifecycle Callbacks</h3>
    <p>JPA provides annotations for lifecycle event callbacks:</p>

    <pre class="java-code">
<code>
@Entity
public class Employee {
    @Id @GenerateValue
    private Long id;

    @PrePersist
    public void beforePersist() {
        System.out.println("About to persist entity");
    }

    @PostPersist
    public void afterPersist() {
        System.out.println("Entity persisted");
    }

    @PreUpdate
    public void beforeUpdate() {
        System.out.println("About to update entity");
    }

    @PostUpdate
    public void afterUpdate() {
        System.out.println("Entity updated");
    }

    @PreRemove
    public void beforeRemove() {
        System.out.println("About to remove entity");
    }

    @PostRemove
    public void afterRemove() {
        System.out.println("Entity removed");
    }

    @PostLoad
    public void afterLoad() {
        System.out.println("Entity loaded from database");
    }
}
</code>
</pre>

    <h3>9. Best Practices</h3>
    <ul>
        <li>Use managed entities for automatic dirty checking</li>
        <li>Be cautious with detached entities - they can cause LazyInitializationException</li>
        <li>Use merge() carefully as it can return a different object instance</li>
        <li>Consider using DTOs instead of passing entities between layers</li>
        <li>Use lifecycle callbacks for auditing and validation</li>
    </ul>
    <br>
    <hr>
    <br>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../spring/transactions.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../spring/caching.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>