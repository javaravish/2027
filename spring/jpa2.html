<!DOCTYPE html>
<html lang="en">
<head>
    <title>JPA</title>

    <!-- Stylesheet -->
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="spring">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">â˜°</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="intro.html">Spring</a>
        <span class="separator">/</span>
        <a href="#">JPA</a>
    </div>
</nav>
<!-- Components will be inserted here by components.js -->

<!-- Main Content Section -->
<main id="content">
    <h1>JPA Query Optimization Techniques</h1>

    <h2>1. Entity Graphs (Fetch Graphs)</h2>
    <p>Entity Graphs help control eager/lazy loading behavior to avoid N+1 query problems.</p>
    <p><strong>Problem:</strong> N+1 Query Issue:</p>

    <pre class="sql-code">
  <code>
    <span class="comment">-- First query: get all customers</span>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customers;

    <span class="comment">-- Then for each customer, another query:</span>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id = ?;
    <span class="comment">-- This results in N+1 queries (1 + number of customers)</span>
  </code>
</pre>

    <h3>Solution: Entity Graph Implementation</h3>

    <pre class="java-code">
  <code>
    <span class="annotation">@Entity</span>
    <span class="annotation">@NamedEntityGraph</span>(
      name = <span class="string">"Customer.withOrdersAndAddress"</span>,
      attributeNodes = {
        <span class="annotation">@NamedAttributeNode</span>(<span class="string">"orders"</span>),
        <span class="annotation">@NamedAttributeNode</span>(value = <span
          class="string">"address"</span>, subgraph = <span class="string">"address.details"</span>)
      },
      subgraphs = <span class="annotation">@NamedSubgraph</span>(
        name = <span class="string">"address.details"</span>,
        attributeNodes = {
          <span class="annotation">@NamedAttributeNode</span>(<span class="string">"city"</span>),
          <span class="annotation">@NamedAttributeNode</span>(<span class="string">"country"</span>)
        }
      )
    )
    <span class="keyword">public class</span> <span class="class">Customer</span> {
      <span class="annotation">@Id</span>
      <span class="annotation">@GeneratedValue</span>
      <span class="keyword">private</span> <span class="class">Long</span> id;
      <span class="keyword">private</span> <span class="class">String</span> name;

      <span class="annotation">@OneToMany</span>(mappedBy = <span class="string">"customer"</span>, fetch = <span
          class="class">FetchType</span>.LAZY)
      <span class="keyword">private</span> <span class="class">List</span>&lt;<span class="class">Order</span>&gt; orders = <span
          class="keyword">new</span> <span class="class">ArrayList</span>&lt;&gt;();

      <span class="annotation">@OneToOne</span>(fetch = <span class="class">FetchType</span>.LAZY)
      <span class="keyword">private</span> <span class="class">Address</span> address;
    }
  </code>
</pre>

    <pre class="java-code">
  <code>
    <span class="annotation">@Entity</span>
    <span class="keyword">public class</span> <span class="class">Order</span> {
      <span class="annotation">@Id</span>
      <span class="annotation">@GeneratedValue</span>
      <span class="keyword">private</span> <span class="class">Long</span> id;
      <span class="keyword">private</span> <span class="class">LocalDate</span> orderDate;

      <span class="annotation">@ManyToOne</span>(fetch = <span class="class">FetchType</span>.LAZY)
      <span class="keyword">private</span> <span class="class">Customer</span> customer;

      <span class="annotation">@OneToMany</span>(mappedBy = <span class="string">"order"</span>, fetch = <span
          class="class">FetchType</span>.LAZY)
      <span class="keyword">private</span> <span class="class">List</span>&lt;<span class="class">OrderItem</span>&gt; items;
    }
  </code>
</pre>

    <pre class="java-code">
  <code>
    <span class="comment">// Repository usage</span>
    <span class="keyword">public interface</span> <span class="class">CustomerRepository</span> <span class="keyword">extends</span> <span
          class="class">JpaRepository</span>&lt;<span class="class">Customer</span>, <span class="class">Long</span>&gt; {

      <span class="annotation">@EntityGraph</span>(value = <span class="string">"Customer.withOrdersAndAddress"</span>, type = <span
          class="class">EntityGraphType</span>.FETCH)
      <span class="class">List</span>&lt;<span class="class">Customer</span>&gt; <span class="method">findByNameContaining</span>(<span
          class="class">String</span> name);

      <span class="annotation">@EntityGraph</span>(attributePaths = {<span class="string">"orders"</span>, <span
          class="string">"orders.items"</span>})
      <span class="class">Optional</span>&lt;<span class="class">Customer</span>&gt; <span class="method">findWithOrdersAndItemsById</span>(<span
          class="keyword">long</span> id);
    }
  </code>
</pre>

    <p>Generated SQL with EntityGraph:</p>

    <pre class="sql-code">
  <code>
    <span class="keyword">SELECT</span>
      c.id, c.name,
      o.id, o.order_date, o.customer_id,
      a.id, a.city, a.country,
      i.id, i.product_name, i.quantity
    <span class="keyword">FROM</span> customers c
    <span class="keyword">LEFT OUTER JOIN</span> orders o <span class="keyword">ON</span> c.id = o.customer_id
    <span class="keyword">LEFT OUTER JOIN</span> address a <span class="keyword">ON</span> c.address_id = a.id
    <span class="keyword">LEFT OUTER JOIN</span> order_items i <span class="keyword">ON</span> o.id = i.order_id
    <span class="keyword">WHERE</span> c.name <span class="keyword">LIKE</span> <span class="string">'%John%'</span>
  </code>
</pre>

    <p>Benefits: Single query instead of N+1 queries</p>
    <hr>
    <h2>2. Dynamic Insert and Update</h2>

    <p>Reduces SQL statement size by including only changed fields.</p>

    <p>Without Dynamic Insert/Update:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Entity</span>
    <span class="keyword">public class</span> <span class="class">Product</span> {
      <span class="annotation">@Id</span>
      <span class="annotation">@GeneratedValue</span>
      <span class="keyword">private</span> <span class="class">Long</span> id;
      <span class="keyword">private</span> <span class="class">String</span> name;
      <span class="keyword">private</span> <span class="class">String</span> description; <span class="comment">// nullable</span>
      <span class="keyword">private</span> <span class="class">BigDecimal</span> price;
      <span class="keyword">private</span> <span class="class">Integer</span> stock; <span
          class="comment">// nullable</span>
    }
  </code>
</pre>

    <pre class="java-code">
  <code>
    <span class="comment">// When saving only name and price:</span>
    <span class="class">Product</span> product = <span class="keyword">new</span> <span class="class">Product</span>();
    product.<span class="method">setName</span>(<span class="string">"Laptop"</span>);
    product.<span class="method">setPrice</span>(<span class="number">999.99</span>);
    productRepository.<span class="method">save</span>(product);

    <span class="comment">// Generated SQL (includes all fields):</span>
    <span class="keyword">INSERT INTO</span> product (id, name, description, price, stock)
    <span class="keyword">VALUES</span> (null, <span class="string">'Laptop'</span>, null, <span
          class="number">999.99</span>, null);
  </code>
</pre>

    <p>With Dynamic Insert/Update:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Entity</span>
    <span class="annotation">@DynamicInsert</span>
    <span class="annotation">@DynamicUpdate</span>
    <span class="annotation">@SelectBeforeUpdate</span>
    <span class="keyword">public class</span> <span class="class">Product</span> {
      <span class="annotation">@Id</span>
      <span class="annotation">@GeneratedValue</span>
      <span class="keyword">private</span> <span class="class">Long</span> id;

      <span class="annotation">@Column</span>(nullable = <span class="keyword">false</span>)
      <span class="keyword">private</span> <span class="class">String</span> name;

      <span class="keyword">private</span> <span class="class">String</span> description; <span class="comment">// nullable</span>

      <span class="keyword">private</span> <span class="class">BigDecimal</span> price;

      <span class="keyword">private</span> <span class="class">Integer</span> stock; <span
          class="comment">// nullable</span>
    }
  </code>
</pre>

    <pre class="java-code">
  <code>
    <span class="comment">// Same save operation now generates:</span>
    <span class="keyword">INSERT INTO</span> product (name, price)
    <span class="keyword">VALUES</span> (<span class="string">'Laptop'</span>, <span class="number">999.99</span>);

    <span class="comment">// For update:</span>
    product.<span class="method">setStock</span>(<span class="number">10</span>);
    productRepository.<span class="method">save</span>(product);

    <span class="comment">// Generated SQL:</span>
    <span class="keyword">UPDATE</span> product <span class="keyword">SET</span> stock = <span class="number">10</span> <span
          class="keyword">WHERE</span> id = <span class="number">1</span>;
    <span class="comment">// Instead of updating all fields</span>
  </code>
</pre>

    <p>Benefits: Smaller SQL statements, better performance, avoids overwriting with null values</p>
    <hr>
    <h2>3. Query Hints with Examples</h2>

    <p>Provide additional instructions to the JPA provider for query optimization.</p>

    <p>Read-Only Query Hint:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@QueryHints</span>({
      <span class="annotation">@QueryHint</span>(name = <span
          class="string">"org.hibernate.readOnly"</span>, value = <span class="string">"true"</span>),
      <span class="annotation">@QueryHint</span>(name = <span class="string">"javax.persistence.query.timeout"</span>, value = <span
          class="string">"3000"</span>),
      <span class="annotation">@QueryHint</span>(name = <span
          class="string">"org.hibernate.fetchSize"</span>, value = <span class="string">"100"</span>)
    })
    <span class="annotation">@Query</span>(<span
          class="string">"SELECT p FROM Product p WHERE p.price > :minPrice"</span>)
    <span class="class">List</span>&lt;<span class="class">Product</span>&gt; <span
          class="method">findExpensiveProducts</span>(<span class="annotation">@Param</span>(<span class="string">"minPrice"</span>) <span
          class="class">BigDecimal</span> minPrice);
  </code>
</pre>

    <p>Generated SQL:</p>

    <pre class="sql-code">
  <code>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> price &gt; <span
          class="number">100.00</span>
  </code>
</pre>

    <p>Benefits: No dirty checking, reduced memory usage, query timeout protection</p>

    <p>Cache Hints:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@QueryHints</span>({
      <span class="annotation">@QueryHint</span>(name = <span
          class="string">"org.hibernate.cacheable"</span>, value = <span class="string">"true"</span>),
      <span class="annotation">@QueryHint</span>(name = <span class="string">"org.hibernate.cacheRegion"</span>, value = <span
          class="string">"productQueries"</span>)
    })
    <span class="annotation">@Query</span>(<span
          class="string">"SELECT p FROM Product p WHERE p.category = :category"</span>)
    <span class="class">List</span>&lt;<span class="class">Product</span>&gt; <span class="method">findByCategory</span>(<span
          class="annotation">@Param</span>(<span class="string">"category"</span>) <span class="class">String</span> category);
  </code>
</pre>

    <p>Benefits: Second-level cache usage, reduced database load</p>

    <p>Locking Hints:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@QueryHints</span>(<span class="annotation">@QueryHint</span>(name = <span class="string">"javax.persistence.lock.timeout"</span>, value = <span
          class="string">"5000"</span>))
    <span class="annotation">@Lock</span>(<span class="class">LockModeType</span>.PESSIMISTIC_WRITE)
    <span class="annotation">@Query</span>(<span class="string">"SELECT p FROM Product p WHERE p.id = :id"</span>)
    <span class="class">Optional</span>&lt;<span class="class">Product</span>&gt; <span
          class="method">findByIdForUpdate</span>(<span class="annotation">@Param</span>(<span
          class="string">"id"</span>) <span class="keyword">long</span> id);
  </code>
</pre>

    <p>Generated SQL:</p>

    <pre class="sql-code">
  <code>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id = <span
          class="number">1</span> <span class="keyword">FOR UPDATE WAIT</span> <span class="number">5</span>;
  </code>
</pre>
    <hr>
    <h2>4. Join Fetch Optimization</h2>

    <p>Without Join Fetch (N+1 Problem):</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Query</span>(<span class="string">"SELECT o FROM Order o"</span>)
    <span class="class">List</span>&lt;<span class="class">Order</span>&gt; <span class="method">findAllOrders</span>();

    <span class="comment">// Generated SQL:</span>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders; <span
          class="comment">-- First query</span>
    <span class="comment">-- Then for each order:</span>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> order.items <span
          class="keyword">WHERE</span> order_id = ?; <span class="comment">-- N queries</span>
    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> id = ?; <span
          class="comment">-- N queries</span>
  </code>
</pre>

    <p>With Join Fetch:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Query</span>(<span class="string">"SELECT o FROM Order o " +</span>
      <span class="string">"JOIN FETCH o.customer " +</span>
      <span class="string">"JOIN FETCH o.items " +</span>
      <span class="string">"LEFT JOIN FETCH o.payments"</span>)
    <span class="class">List</span>&lt;<span class="class">Order</span>&gt; <span class="method">findAllOrdersWithDetails</span>();

    <span class="comment">// Generated SQL:</span>
    <span class="keyword">SELECT</span>
      o.*, c.*, i.*, p.*
    <span class="keyword">FROM</span> orders o
    <span class="keyword">INNER JOIN</span> customer c <span class="keyword">ON</span> o.customer_id = c.id
    <span class="keyword">INNER JOIN</span> order.items i <span class="keyword">ON</span> o.id = i.order_id
    <span class="keyword">LEFT JOIN</span> payments p <span class="keyword">ON</span> o.id = p.order_id
  </code>
</pre>

    <p>Benefits: Single query instead of 1 + 2N queries</p>
    <hr>
    <h2>5. Batch Processing</h2>

    <p>Optimize bulk operations to reduce database roundtrips.</p>

    <p>Batch Insert:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Service</span>
    <span class="annotation">@Transactional</span>
    <span class="keyword">public class</span> <span class="class">BatchService</span> {

      <span class="annotation">@PersistenceContext</span>
      <span class="keyword">private</span> <span class="class">EntityManager</span> entityManager;

      <span class="keyword">public void</span> <span class="method">batchInsertProducts</span>(<span
          class="class">List</span>&lt;<span class="class">Products</span>&gt; products) {
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; products.<span
          class="method">size</span>(); i++) {
          entityManager.<span class="method">persist</span>(products.<span class="method">get</span>(i));

          <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span> && i &gt; <span
          class="number">0</span>) {
            entityManager.<span class="method">flush</span>();
            entityManager.<span class="method">clear</span>();
          }
        }
      }
    }
  </code>
</pre>

    <p>Generated SQL:</p>

    <pre class="sql-code">
  <code>
    <span class="comment">-- Instead of 1000 individual INSERT statements:</span>
    <span class="keyword">INSERT INTO</span> product (name, price) <span class="keyword">VALUES</span> (?, ?);
    <span class="keyword">INSERT INTO</span> product (name, price) <span class="keyword">VALUES</span> (?, ?);
    ...

    <span class="comment">-- With batch processing and proper JDBC configuration:</span>
    <span class="comment">-- Hibernate uses JDBC batching:</span>
    <span class="keyword">INSERT INTO</span> product (name, price) <span class="keyword">VALUES</span> (?, ?), (?, ?), (?, ?)....;
  </code>
</pre>

    <p>Batch Update:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Modifying</span>
    <span class="annotation">@Query</span>(<span class="string">"UPDATE Product p SET p.price = p.price * :factor WHERE p.category = :category"</span>)
    <span class="annotation">@QueryHints</span>(<span class="annotation">@QueryHint</span>(name = <span class="string">"org.hibernate.hql.internal.QueryImpl.BATCH_SIZE"</span>,
      value = <span class="string">"1000"</span>))
    <span class="keyword">int</span> <span class="method">updateProductPrices</span>(<span
          class="annotation">@Param</span>(<span class="string">"category"</span>) <span class="class">String</span> category,
      <span class="annotation">@Param</span>(<span class="string">"factor"</span>) <span class="class">BigDecimal</span> factor);
  </code>
</pre>

    <p>Generated SQL:</p>

    <pre class="sql-code">
  <code>
    <span class="keyword">UPDATE</span> product
    <span class="keyword">SET</span> price = price * <span class="number">1.1</span>
    <span class="keyword">WHERE</span> category = <span class="string">'ELECTRONICS'</span>;
    <span class="comment">-- Single query instead of multiple updates</span>
  </code>
</pre>
    <hr>
    <h2>6. Projection/DTO Optimization</h2>

    <p>Reduce data transfer by using projections and DTOs.</p>

    <p>Interface Projection:</p>

    <pre class="java-code">
  <code>
    <span class="keyword">public interface</span> <span class="class">ProductSummary</span> {
      <span class="class">String</span> <span class="method">getName</span>();
      <span class="class">BigDecimal</span> <span class="method">getPrice</span>();
      <span class="class">String</span> <span class="method">getCategoryName</span>();

      <span class="keyword">default</span> <span class="class">String</span> <span class="method">getDisplayInfo</span>() {
        <span class="keyword">return</span> <span class="method">getName</span>() + <span class="string">" - $"</span> + <span
          class="method">getPrice</span>();
      }
    }

    <span class="annotation">@Query</span>(<span class="string">"SELECT p.name as name, p.price as price, c.name as categoryName " +</span>
      <span class="string">"FROM Product p JOIN p.category c " +</span>
      <span class="string">"WHERE p.stock > 0"</span>)
    <span class="class">List</span>&lt;<span class="class">ProductSummary</span>&gt; <span class="method">findAvailableProducts</span>();
  </code>
</pre>

    <p><strong>Generated SQL:</strong></p>

    <pre class="sql-code">
  <code>
    <span class="keyword">SELECT</span> p.name, p.price, c.name
    <span class="keyword">FROM</span> product p
    <span class="keyword">JOIN</span> category c <span class="keyword">ON</span> p.category_id = c.id
    <span class="keyword">WHERE</span> p.stock &gt; <span class="number">0</span>;
  </code>
</pre>

    <p><strong>Class-based DTO:</strong></p>

    <pre class="java-code">
  <code>
    <span class="keyword">public class</span> <span class="class">ProductDTO</span> {
      <span class="keyword">private</span> <span class="class">String</span> name;
      <span class="keyword">private</span> <span class="class">BigDecimal</span> price;
      <span class="keyword">private</span> <span class="class">String</span> category;

      <span class="keyword">public</span> <span class="method">ProductDTO</span>(<span class="class">String</span> name, <span
          class="class">BigDecimal</span> price, <span class="class">String</span> category) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.price = price;
        <span class="keyword">this</span>.category = category;
      }
    }

    <span class="annotation">@Query</span>(<span class="string">"SELECT new com.example.dto.ProductDTO(p.name, p.price, c.name) " +</span>
      <span class="string">"FROM Product p JOIN p.category c"</span>)
    <span class="class">List</span>&lt;<span class="class">ProductDTO</span>&gt; <span
          class="method">findAllProductDTOs</span>();
  </code>
</pre>

    <p><strong>Benefits:</strong> Reduced data transfer, no unnecessary fields selected</p>
    <hr>
    <h2>7. Second Level Cache</h2>

    <p><strong>Entity Cache Configuration:</strong></p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Entity</span>
    <span class="annotation">@Cacheable</span>
    <span class="annotation">@org.hibernate.annotations.Cache</span>(
      usage = <span class="class">CacheConcurrencyStrategy</span>.READ_WRITE,
      region = <span class="string">"productCache"</span>
    )
    <span class="keyword">public class</span> <span class="class">Product</span> {
      <span class="annotation">@Id</span>
      <span class="annotation">@GeneratedValue</span>
      <span class="keyword">private</span> <span class="class">Long</span> id;
      <span class="keyword">private</span> <span class="class">String</span> name;
      <span class="keyword">private</span> <span class="class">BigDecimal</span> price;

      <span class="annotation">@ManyToMany</span>
      <span class="annotation">@Cache</span>(usage = <span class="class">CacheConcurrencyStrategy</span>.READ_WRITE)
      <span class="keyword">private</span> <span class="class">Set</span>&lt;<span class="class">Category</span>&gt; categories;
    }
  </code>
</pre>

    <p>Cache Usage:</p>

    <pre class="java-code">
  <code>
    <span class="comment">// First call - hits database</span>
    <span class="class">Product</span> product = productRepository.<span class="method">findById</span>(<span
          class="number">11</span>).<span class="method">orElseThrow</span>();
    <span class="comment">// Generated SQL: SELECT * FROM product WHERE id = 1</span>

    <span class="comment">// Second call - hits cache</span>
    <span class="class">Product</span> cachedProduct = productRepository.<span class="method">findById</span>(<span
          class="number">11</span>).<span class="method">orElseThrow</span>();
    <span class="comment">// No SQL generated - data served from cache</span>
  </code>
</pre>
    <hr>
    <h2>8. Native Query Optimization</h2>

    <p>Use native queries for complex operations when JPQL isn't efficient.</p>

    <p>Complex Reporting Query:</p>

    <pre class="java-code">
  <code>
    <span class="keyword">public interface</span> <span class="class">OrderRepository</span> <span class="keyword">extends</span> <span
          class="class">JpaRepository</span>&lt;<span class="class">Order</span>, <span class="class">Long</span>&gt; {

      <span class="annotation">@Query</span>(value = <span class="string">"""
        SELECT
          c.name as customer_name,
          EXTRACT(YEAR FROM o.order_date) as year,
          EXTRACT(MONTH FROM o.order_date) as month,
          COUNT(o.id) as order_count,
          SUM(oi.quantity * oi.unit_price) as total_amount
        FROM orders o
        JOIN customers c ON o.customer_id = c.id
        JOIN order-items oi ON o.id = oi.order_id
        WHERE o.order_date BETWEEN :startDate AND :endDate
        GROUP BY c.name, EXTRACT(YEAR FROM o.order_date), EXTRACT(MONTH FROM o.order_date)
        ORDER BY total_amount DESC
        """</span>,
        nativeQuery = <span class="keyword">true</span>)
      <span class="class">List</span>&lt;<span class="class">Object</span>[]&gt; <span
          class="method">getSalesReport</span>(<span class="annotation">@Param</span>(<span
          class="string">"startDate"</span>) <span class="class">LocalDate</span> startDate,
        <span class="annotation">@Param</span>(<span class="string">"endDate"</span>) <span
          class="class">LocalDate</span> endDate);
    }
  </code>
</pre>

    <p>Benefits: Database-specific optimizations, complex aggregations</p>
    <hr>
    <h2>9. Monitoring and Statistics</h2>

    <p>Configuration:</p>

    <pre class="code-block">
  <code>
    <span class="comment"># application.properties</span>
    <span class="key">spring.jpa.properties.hibernate.generate_statistics</span>=<span class="value">true</span>
    <span class="key">spring.ipa.properties.hibernate.session.factory.statement_inspector</span>=<span class="value">com.example.SqlInspector</span>
  </code>
</pre>

    <p>Custom SQL Inspector:</p>

    <pre class="java-code">
  <code>
    <span class="keyword">public class</span> <span class="class">SqlInspector</span> <span
          class="keyword">implements</span> <span class="class">StatementInspector</span> {
      <span class="keyword">private static final</span> <span class="class">Logger</span> log = <span class="class">LoggerFactory</span>.<span
          class="method">getLogger</span>(<span class="class">SqlInspector</span>.<span class="keyword">class</span>);
    }

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="class">String</span> <span class="method">inspect</span>(<span
          class="class">String</span> sql) {
      <span class="keyword">if</span> (sql.<span class="method">tolowerCase</span>().<span
          class="method">startsWith</span>(<span class="string">"select"</span>)) {
        log.<span class="method">debug</span>(<span class="string">"Executing query: {}"</span>, sql);
        <span class="comment">// Add query analysis logic here</span>
      }
      <span class="keyword">return</span> sql;
    }
  </code>
</pre>

    <p>Statistics Usage:</p>

    <pre class="java-code">
  <code>
    <span class="annotation">@Service</span>
    <span class="keyword">public class</span> <span class="class">QueryMonitorService</span> {

      <span class="annotation">@PersistenceContext</span>
      <span class="keyword">private</span> <span class="class">EntityManager</span> entityManager;

      <span class="keyword">public void</span> <span class="method">logStatistics</span>() {
        <span class="class">Statistics</span> stats = entityManager.<span class="method">getEntityManagerFactory</span>()
          .<span class="method">umwrap</span>(<span class="class">SessionFactory</span>.<span
          class="keyword">class</span>)
          .<span class="method">getStatistics</span>();

        log.<span class="method">info</span>(<span class="string">"Query Execution Count: {}"</span>, stats.<span
          class="method">getQueryExecutionCount</span>());
        log.<span class="method">info</span>(<span class="string">"SLow Queries: {}"</span>, stats.<span class="method">getQueryStatistics</span>().<span
          class="method">values</span>().<span class="method">stream</span>())
          .<span class="method">filter</span>(qs -&gt; qs.<span class="method">getExecutionAvgTime</span>() &gt; <span
          class="number">100</span>)
          .<span class="method">count</span>());
      }
    }
  </code>
</pre>
    <hr>
    <h3>Performance Comparison Table</h3>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Technique</th>
                <th>Before Optimization</th>
                <th>After Optimization</th>
                <th>Improvement</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Entity Graph</td>
                <td>N+1 queries (101 queries)</td>
                <td>1 query</td>
                <td>100x reduction</td>
            </tr>
            <tr>
                <td>Dynamic Insert</td>
                <td>INSERT all fields</td>
                <td>INSERT only set fields</td>
                <td>2-5x faster</td>
            </tr>
            <tr>
                <td>Batch Processing</td>
                <td>1000 individual INSERTs</td>
                <td>20 batched INSERTs</td>
                <td>50x faster</td>
            </tr>
            <tr>
                <td>Join Fetch</td>
                <td>1 + 2N queries</td>
                <td>1 query</td>
                <td>(1+2N)x faster</td>
            </tr>
            <tr>
                <td>Query Cache</td>
                <td>Database hits</td>
                <td>Cache hits</td>
                <td>10-100x faster</td>
            </tr>
            <tr>
                <td>Projections</td>
                <td>SELECT *</td>
                <td>SELECT specific columns</td>
                <td>2-10x less data</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>Best Practices Summary</h3>

    <ol>
        <li><strong>Always use Entity Graphs</strong> for relationships to avoid N+1</li>
        <li><strong>Enable Dynamic Insert/Update</strong> for entities with many nullable fields</li>
        <li><strong>Use batch processing</strong> for bulk operations (set hibernate.jdbc.batch_size )</li>
        <li><strong>Apply query hints</strong> for read-only operations, caching, and timeouts</li>
        <li><strong>Use projections/DTOs</strong> to minimize data transfer</li>
        <li><strong>Implement second-level caching</strong> for reference data</li>
        <li><strong>Monitor query performance</strong> regularly</li>
        <li><strong>Use native queries</strong> for complex reporting needs</li>
        <li><strong>Enable SQL logging</strong> in development (spring.jpa.show-sql=true )</li>
        <li><strong>Regularly analyze</strong> query execution plans</li>
    </ol>

    <p>By implementing these JPA query optimization techniques, you can significantly improve application performance,
        reduce database load, and provide better user experience.</p>
    <hr>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../spring/jpa.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../spring/caching.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>