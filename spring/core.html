<!DOCTYPE html>
<html lang="en">
<head>
    <title>Core</title>

    <!-- Stylesheet -->
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="spring">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">â˜°</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="#">Spring</a>
        <span class="separator">/</span>
        <a href="#">Core</a>
    </div>
</nav>
<!-- Components will be inserted here by components.js -->

<!-- Main Content Section -->
<main id="content">
    <h2>1. What is Spring Framework?</h2>

    <p>Spring is a <strong>lightweight, open-source framework</strong> used to build <strong>Java-based enterprise
        applications</strong>. It promotes <strong>loose coupling</strong> through <strong>Dependency Injection
        (DI)</strong> and supports <strong>Aspect-Oriented Programming (AOP)</strong>.</p>
    <hr>
    <h2>2. Inversion of Control (IoC) in Spring</h2>

    <p><strong>Inversion of Control (IoC)</strong> in Spring is a <strong>design principle</strong> where the control of
        object creation and dependency management is <strong>transferred</strong> from the programmer to the <strong>Spring
            IoC container</strong>.</p>

    <ul>
        <li>The <strong>Spring container creates the objects</strong> (beans), manages their lifecycle, and <strong>injects
            dependencies</strong> automatically.
        </li>
    </ul>

    <h3>Types of Dependency Injection in Spring IoC</h3>

    <ol>
        <li><strong>Constructor Injection</strong>: Dependencies provided through class constructors</li>
        <li><strong>Setter Injection</strong>: Dependencies injected through setter methods</li>
        <li><strong>Field Injection</strong>: Dependencies injected directly into fields (using @Autowired)</li>
    </ol>

    <h3>Benefits of IoC in Spring</h3>

    <ul>
        <li><strong>Loose coupling</strong>: Components are less dependent on each other</li>
        <li><strong>Easier testing</strong>: Dependencies can be easily mocked</li>
        <li><strong>Better modularity</strong>: Components are more reusable</li>
        <li><strong>Simplified configuration</strong>: Centralized management of components</li>
        <li><strong>Lifecycle management</strong>: Container handles object creation and destruction</li>
    </ul>
    <hr>
    <h2>3. Dependency Injection (DI)</h2>

    <p>Dependency Injection is the concrete implementation of the Inversion of Control (IoC) principle in Spring, where
        the framework provides dependencies to objects rather than having objects create their own dependencies.</p>

    <p>Dependency Injection is what makes Spring so powerful, enabling loose coupling, easier testing, and more
        maintainable code architecture.</p>

    <h3>How Dependency Injection Works in Spring</h3>

    <ol>
        <li>Component Scanning and Bean Definition
            <ul>
                <li>@ComponentScan: Spring scans specified packages for classes annotated with @Component, @Service,
                    @Repository, @Controller, etc.
                </li>
                <li>Bean Definition: For each found class, Spring creates a bean definition in the BeanFactory (the core
                    container)
                </li>
            </ul>
        </li>
        <li>Bean Instantiation
            <ul>
                <li>When the application starts, Spring creates an instance of the ApplicationContext</li>
                <li>The context reads configuration metadata (annotations or XML) and creates bean definitions</li>
                <li>Beans are instantiated either eagerly (at startup) or lazily (when first requested)</li>
            </ul>
        </li>
        <li>Dependency Resolution
            <ul>
                <li>Spring analyzes dependencies through:
                    <ul>
                        <li>Constructor parameters (@Autowired on constructor)</li>
                        <li>Setter methods (@Autowired on setter methods)</li>
                        <li>Fields directly (@Autowired on fields)</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Dependency Injection Process
            <ol>
                <li>Autowiring: Spring identifies dependencies that need to be injected</li>
                <li>Dependency Lookup: The container looks for matching beans in its context</li>
                <li>Injection: The container injects the dependencies before the bean is fully initialized.</li>
            </ol>
        </li>
    </ol>

    <h3>Internal Workflow</h3>

    <p>Here's what happens under the hood:</p>

    <ol>
        <li>Startup Phase:
            <ul>
                <li>ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</li>
                <li>Spring parses configuration</li>
                <li>Creates BeanDefinition objects for each bean</li>
                <li>Stores them in a bean definition registry</li>
            </ul>
        </li>
        <li>Bean Creation:
            <ul>
                <li>When a bean is needed, Spring calls AbstractAutowireCapableBeanFactory.createBean()</li>
                <li>This triggers doCreateBean() which:
                    <ul>
                        <li>Instantiates the bean (via constructor or factory method)</li>
                        <li>Populates bean properties (dependency injection)</li>
                        <li>Initializes the bean (calls @PostConstruct methods)</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Dependency Injection:
            <ul>
                <li>Handled by AutowiredAnnotationBeanPostProcessor</li>
                <li>Uses reflection to inspect fields/methods marked with @Autowired</li>
                <li>Resolves dependencies from the application context</li>
                <li>Injects them via reflection (Field.set() or Method.invoke())</li>
            </ul>
        </li>
    </ol>

    <hr>
    <h2>4. Types of Dependency Injection in Spring</h2>

    <p>Spring Framework supports three main types of dependency injection, each with its own use cases and
        advantages:</p>

    <ol>
        <li><strong>Constructor-Based Injection (Recommended)</strong>

            <h4>How it works:</h4>
            <ul>
                <li>Dependencies are provided through a class constructor</li>
                <li>Spring automatically wires dependencies when creating the bean</li>
                <li>Bean Detection
                    <ul>
                        <li>Spring scans classes annotated with @Component, @Service, @Repository, etc.</li>
                        <li>If a class has a constructor with @Autowired (optional in Spring 4.3+ for single
                            constructor), Spring identifies it for Constructor Injection.
                        </li>
                    </ul>
                </li>
                <li>Dependency Resolution
                    <ul>
                        <li>The DefaultistableBeanFactory checks the dependencies needed for the constructor.</li>
                        <li>If multiple beans of the same type exist, Spring uses:
                            <ul>
                                <li>@Qualifier to specify which bean to inject.</li>
                                <li>Parameter name matching (if -parameters compiler flag is enabled).</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>Instantiation & Injection
                    <ul>
                        <li>Spring uses Java Reflection (Constructor.newInstance() ) to create the bean.</li>
                        <li>Dependencies are resolved and injected before the object is fully constructed.</li>
                    </ul>
                </li>
            </ul>

            <h4>Implementation:</h4>
            <pre class="java-code">
<code>
<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">OrderService</span> {
    <span class="keyword">private final</span> <span class="class">PaymentProcessor</span> <span class="var">paymentProcessor</span>;
    <span class="keyword">private final</span> <span class="class">InventoryService</span> <span class="var">inventoryService</span>;

    <span class="comment">// @Autowired optional in Spring 4.3+ for single constructor</span>
    <span class="keyword">public</span> <span class="class">OrderService</span>(<span
        class="class">PaymentProcessor</span> <span class="var">paymentProcessor</span>,
    <span class="class">InventoryService</span> <span class="var">inventoryService</span>) {
    <span class="keyword">this</span>.<span class="var">paymentProcessor</span> = <span
        class="var">paymentProcessor</span>;
    <span class="keyword">this</span>.<span class="var">inventoryService</span> = <span
        class="var">inventoryService</span>;
    }
}
</code>
</pre>

            <h4>Advantages:</h4>
            <ul>
                <li>Immutable dependencies (fields can be final)</li>
                <li>Clearly defines mandatory dependencies</li>
                <li>Easier testing (no need for Spring context in unit tests)</li>
                <li>Prevents circular dependencies</li>
                <li>Recommended by Spring team</li>
            </ul>
        </li>

        <li><strong>Setter-Based Injection</strong>

            <h4>How it works:</h4>
            <ul>
                <li>Dependencies are injected through setter methods</li>
                <li>Useful for optional dependencies or when reconfiguration is needed</li>
                <li>Allows reconfiguration (dependencies can be changed later)</li>
                <li>Not immutable (fields cannot be final )</li>
                <li>Good for optional dependencies</li>
                <li>Bean Instantiation
                    <ul>
                        <li>Spring first creates the bean using the default constructor (no-args constructor must
                            exist).
                        </li>
                    </ul>
                </li>
                <li>Dependency Injection via Setters
                    <ul>
                        <li>The AutowiredAnnotationBeanPostProcessor processes methods annotated with @Autowired .</li>
                        <li>Uses reflection (Method.invoke() ) to call the setter method and inject the dependency.</li>
                    </ul>
                </li>
                <li>Optional Dependencies
                    <ul>
                        <li>If @Autowired(required = false), Spring skips injection if the bean is missing.</li>
                    </ul>
                </li>
            </ul>

            <h4>Implementation:</h4>
            <pre class="java-code">
<code>
<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">UserService</span> {
    <span class="keyword">private</span> <span class="class">UserRepository</span> <span
        class="var">userRepository</span>;
    <span class="keyword">private</span> <span class="class">EmailService</span> <span class="var">emailService</span>;

    <span class="annotation">@Autowired</span>
    <span class="keyword">public void</span> <span class="method">setUserRepository</span>(<span class="class">UserRepository</span> <span
        class="var">userRepository</span>) {
    <span class="keyword">this</span>.<span class="var">userRepository</span> = <span class="var">userRepository</span>;
    }

    <span class="annotation">@Autowired</span>(required = false) <span class="comment">// Optional dependency</span>
    <span class="keyword">public void</span> <span class="method">setEmailService</span>(<span class="class">EmailService</span> <span
        class="var">emailService</span>) {
    <span class="keyword">this</span>.<span class="var">emailService</span> = <span class="var">emailService</span>;
    }
}
</code>
</pre>

            <h4>Advantages:</h4>
            <ul>
                <li>Allows for optional dependencies</li>
                <li>Enables dependency changes at runtime</li>
                <li>Works well with JavaBean convention</li>
            </ul>
        </li>

        <li><strong>Field-Based Injection</strong>

            <h4>How it works:</h4>
            <ul>
                <li>Dependencies are injected directly into fields</li>
                <li>Uses reflection to set private fields</li>
                <li>Avoid in production code (hard to test, violates encapsulation)</li>
                <li>Fast to write (but problematic in long-term)</li>
                <li>Works with @Qualifier for disambiguation</li>
                <li>Bean Instantiation
                    <ul>
                        <li>Spring creates the bean using the default constructor (must exist).</li>
                    </ul>
                </li>
                <li>Field Injection via Reflection
                    <ul>
                        <li>The AutowiredAnnotationBeanPostProcessor scans fields with @Autowired.</li>
                        <li>Uses reflection (Field.set() ) to directly inject dependencies into private fields
                            (bypassing encapsulation).
                        </li>
                    </ul>
                </li>
                <li>Circular Dependency Handling
                    <ul>
                        <li>If a circular dependency exists, Spring may use proxy objects (if @Lazy is used).</li>
                    </ul>
                </li>
            </ul>

            <h4>Implementation:</h4>
            <pre class="java-code">
<code>
<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">ProductService</span> {
    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class">ProductRepository</span> <span class="var">productRepository</span>;

    <span class="annotation">@Autowired</span>
    <span class="annotation">@Qualifier</span>(<span class="string">"discountCalculator"</span>)
    <span class="keyword">private</span> <span class="class">DiscountStrategy</span> <span
        class="var">discountStrategy</span>;
}
</code>
</pre>

            <h4>Advantages:</h4>
            <ul>
                <li>Concise (less boilerplate code)</li>
                <li>Easy to add new dependencies</li>
            </ul>

            <h4>Disadvantages:</h4>
            <ul>
                <li>Harder to test without Spring container</li>
                <li>Violates encapsulation (direct field access)</li>
                <li>Can hide design problems (too many dependencies)</li>
                <li>Not recommended for production code</li>
            </ul>
        </li>
    </ol>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Type</th>
                <th>Immutable</th>
                <th>Testability</th>
                <th>Circular Deps</th>
                <th>Recommended</th>
                <th>Use Case</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Constructor</td>
                <td>Yes</td>
                <td>Excellent</td>
                <td>Prevented</td>
                <td>â˜…â˜…â˜…â˜…â˜…â˜…</td>
                <td>Mandatory deps</td>
            </tr>
            <tr>
                <td>Setter</td>
                <td>No</td>
                <td>Good</td>
                <td>Supported</td>
                <td>â˜…â˜…â˜…â˜†â˜†</td>
                <td>Optional/mutable deps</td>
            </tr>
            <tr>
                <td>Field</td>
                <td>No</td>
                <td>Poor</td>
                <td>Supported</td>
                <td>â˜…â˜†â˜†â˜†â˜†</td>
                <td>Quick prototypes</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>Lifecycle Flow of Dependency Injection</h3>
    <pre class="java-code">

<code><span class="keyword">@ComponentScan -- BeanDefinition creation -- Dependency Resolution -- Object Instantiation -- Injection (Constructor/Setter/Field) -- Bean Initialization -- Ready for use
    </span></code></pre>

    <hr>
    <h2>5. Spring Dependency Resolution Strategies</h2>

    <p>Spring Framework provides multiple strategies for resolving dependencies when injecting beans. Here's a detailed
        explanation of each approach:</p>

    <h3>1. By Name Resolution</h3>

    <p><strong>How it works:</strong></p>

    <ul>
        <li>Spring matches the variable name with the bean name in the container</li>
        <li>Case-sensitive matching is performed</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@Component</span>(<span class="string">"mySpecialService"</span>)
<span class="keyword">public class</span> <span class="class">SpecialServiceImpl</span> <span
        class="keyword">implements</span> <span class="class">MyService</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">ClientService</span> {
    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class">MyService</span> <span class="var">mySpecialService</span>; <span
        class="comment">// matches bean named "mySpecialService"</span>
}
</code>
</pre>

    <p><strong>When to use:</strong></p>

    <ul>
        <li>When you want explicit naming of dependencies</li>
        <li>When working with multiple implementations of the same interface</li>
    </ul>

    <h3>2. By Type Resolution (Default)</h3>

    <p><strong>How it works:</strong></p>

    <ul>
        <li>Spring looks for a bean that matches the required type exactly</li>
        <li>Most common and straightforward approach</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@Repository</span>
<span class="keyword">public class</span> <span class="class">JpaUserRepository</span> <span
        class="keyword">implements</span> <span class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">UserService</span> {
    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class">UserRepository</span> <span
        class="var">userRepository</span>; <span class="comment">// matches by type</span>
}
</code>
</pre>

    <p><strong>When to use:</strong></p>

    <ul>
        <li>For simple applications with one implementation per interface</li>
        <li>When type safety is a priority</li>
    </ul>

    <h3>3. By Qualifier Resolution</h3>

    <p><strong>How it works:</strong></p>

    <ul>
        <li>Uses @Qualifier annotation to specify exact bean</li>
        <li>Works with both explicit bean names and custom qualifiers</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@Repository</span>(<span class="string">"jpaUserRepo"</span>)
<span class="keyword">public class</span> <span class="class">JpaUserRepository</span> <span
        class="keyword">implements</span> <span class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Repository</span>(<span class="string">"mongoUserRepo"</span>)
<span class="keyword">public class</span> <span class="class">MongoUserRepository</span> <span class="keyword">implements</span> <span
        class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">UserService</span> {
    <span class="annotation">@Autowired</span>
    <span class="annotation">@Qualifier</span>(<span class="string">"jpaUserRepo"</span>)
    <span class="keyword">private</span> <span class="class">UserRepository</span> <span
        class="var">userRepository</span>;
}
</code>
</pre>

    <p><strong>When to use:</strong></p>

    <ul>
        <li>When multiple implementations exist and you need to specify which one to use</li>
        <li>For more explicit wiring than name matching alone</li>
    </ul>

    <h3>4. By Primary Resolution</h3>

    <p><strong>How it works:</strong></p>

    <ul>
        <li>@Primary marks a bean as the default choice</li>
        <li>Used when no other qualifier is specified</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@Repository</span>
<span class="annotation">@Primary</span>
<span class="keyword">public class</span> <span class="class">JpaUserRepository</span> <span
        class="keyword">implements</span> <span class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Repository</span>
<span class="keyword">public class</span> <span class="class">MongoUserRepository</span> <span class="keyword">implements</span> <span
        class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">UserService</span> {
    <span class="annotation">@Autowired</span>
    <span class="keyword">private</span> <span class="class">UserRepository</span> <span
        class="var">userRepository</span>; <span class="comment">// will inject JpaUserRepository</span>
}
</code>
</pre>

    <p><strong>When to use:</strong></p>

    <ul>
        <li>When you have a default implementation among several options</li>
        <li>To simplify configuration in most common cases</li>
    </ul>
    <hr>
    <h2>5. Custom Qualifier Resolution</h2>

    <p><strong>How it works:</strong></p>

    <ul>
        <li>Create custom annotation meta-annotated with @Qualifier</li>
        <li>Provides type-safe way to qualify beans</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@Target</span>({<span class="class">ElementType</span>.<span class="var">FIELD</span>, <span
        class="class">ElementType</span>.<span class="var">PARAMETER</span>, <span
        class="class">ElementType</span>.<span class="var">TYPE</span>})
<span class="annotation">@Retention</span>(<span class="class">RetentionPolicy</span>.<span class="var">RUNTIME</span>)
<span class="annotation">@Qualifier</span>
<span class="keyword">public @interface</span> <span class="class">DatabaseType</span> {
    <span class="class">String</span> <span class="method">value</span>();
}

<span class="annotation">@Repository</span>
<span class="annotation">@DatabaseType</span>(<span class="string">"jpa"</span>)
<span class="keyword">public class</span> <span class="class">JpaUserRepository</span> <span
        class="keyword">implements</span> <span class="class">UserRepository</span> {
    <span class="comment">// implementation</span>
}

<span class="annotation">@Service</span>
<span class="keyword">public class</span> <span class="class">UserService</span> {
    <span class="annotation">@Autowired</span>
    <span class="annotation">@DatabaseType</span>(<span class="string">"jpa"</span>)
    <span class="keyword">private</span> <span class="class">UserRepository</span> <span
        class="var">userRepository</span>;
}
</code>
</pre>

    <p><strong>When to use:</strong></p>

    <ul>
        <li>When you need more semantic qualification than simple strings</li>
        <li>For better compile-time safety</li>
        <li>When building larger systems with complex dependency requirements</li>
    </ul>

    <h3>Resolution Order of Precedence</h3>

    <p>When multiple strategies could apply, Spring uses this order:</p>

    <ol>
        <li>@Qualifier annotation (explicit or custom)</li>
        <li>By name matching (variable name to bean name)</li>
        <li>@Primary designated bean</li>
        <li>By type matching (if only one matching bean exists)</li>
    </ol>


    <hr>

    <h2>6. BeanFactory vs. ApplicationContext in Spring</h2>

    <p>Both BeanFactory and ApplicationContext are core containers in Spring, but they serve different purposes and have
        distinct capabilities. Below is a detailed comparison:</p>

    <h3>1. BeanFactory</h3>

    <h3>What It Is</h3>

    <ul>
        <li>The basic container that provides the fundamental DI (Dependency Injection) support.</li>
        <li>Defined in the org.springframework.beans package.</li>
        <li>Lazily initializes beans (only when getBean() is called).</li>
    </ul>

    <h3>Key Features</h3>

    <ul>
        <li>âœ” Core DI support (manages bean lifecycle)</li>
        <li>âœ” Lazy loading (beans are created only when requested)</li>
        <li>âœ” Lightweight (minimal memory footprint)</li>
        <li>âœ” No built-in AOP, event handling, or enterprise features</li>
    </ul>

    <h3>Example Usage</h3>

    <pre class="java-code">
<code>
<span class="class">Resource</span> <span class="var">resource</span> = <span class="keyword">new</span> <span
        class="class">ClassPathResource</span>(<span class="string">"beans.xml"</span>);
<span class="class">BeanFactory</span> <span class="var">factory</span> = <span class="keyword">new</span> <span
        class="class">XmlBeanFactory</span>(<span class="var">resource</span>);
<span class="class">MyBean</span> <span class="var">bean</span> = <span class="var">factory</span>.<span class="method">getBean</span>(<span
        class="class">MyBean</span>.<span class="keyword">class</span>);
</code>
</pre>

    <h3>When to Use</h3>

    <ul>
        <li>Memory-constrained environments (where lazy loading is beneficial).</li>
        <li>Simple applications that only need basic DI.</li>
    </ul>

    <h3>2. ApplicationContext</h3>

    <h3>What It Is</h3>

    <ul>
        <li>An advanced container that extends BeanFactory with additional features.</li>
        <li>Defined in the org.springframework.context package.</li>
        <li>Eagerly initializes singleton beans by default (at startup).</li>
    </ul>

    <h3>Key Features (Beyond BeanFactory)</h3>

    <ul>
        <li>âœ” All BeanFactory features (DI, lifecycle management)</li>
        <li>âœ” Automatic @Component scanning (@Service, @Repository, etc.)</li>
        <li>âœ” AOP support (proxying, @Transactional, etc.)</li>
        <li>âœ” Event handling (ApplicationEvent and ApplicationListener )</li>
        <li>âœ” Internationalization (I18n) (MessageSource support)</li>
        <li>âœ” Environment & Profile management (@Profile, Environment )</li>
        <li>âœ” Integration with web frameworks (WebApplicationContext)</li>
    </ul>

    <h3>Example Usage</h3>

    <pre class="java-code">
<code>
<span class="class">ApplicationContext</span> <span class="var">context</span> = <span class="keyword">new</span> <span
        class="class">AnnotationConfigApplicationContext</span>(<span class="class">AppConfig</span>.<span
        class="keyword">class</span>);
<span class="class">MyService</span> <span class="var">service</span> = <span class="var">context</span>.<span
        class="method">getBean</span>(<span class="class">MyService</span>.<span class="keyword">class</span>);
</code>
</pre>
    <h2>Detailed Comparison of ApplicationContext and BeanFactory</h2>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Feature</th>
                <th>BeanFactory</th>
                <th>ApplicationContext</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td><strong>Core Purpose</strong></td>
                <td>Basic Dependency Injection</td>
                <td>Advanced Enterprise Application Framework</td>
            </tr>
            <tr>
                <td><strong>Relationship</strong></td>
                <td>Core Interface for IoC</td>
                <td>Extends the BeanFactory interface</td>
            </tr>
            <tr>
                <td><strong>Loading Strategy</strong></td>
                <td>Lazy-loading (by default). Beans are created only when they are explicitly requested via
                    getBean().
                </td>
                <td>Eager-loading (by default). Singleton beans are created at startup during container initialization.
                    This helps detect configuration errors immediately.
                </td>
            </tr>
            <tr>
                <td><strong>Internationalization (I18n)</strong></td>
                <td>Not Supported</td>
                <td>Supported. Provides getMessage() to resolve messages from property files, supporting different
                    locales.
                </td>
            </tr>
            <tr>
                <td><strong>Event Publishing</strong></td>
                <td>Not Supported</td>
                <td>Supported. Allows publishing and listening to application events using the ApplicationEventPublisher
                    and ApplicationListener interfaces.
                </td>
            </tr>
            <tr>
                <td><strong>AOP Integration</strong></td>
                <td>Basic, requires more manual setup.</td>
                <td>Seamless and automatic integration with Spring AOP.</td>
            </tr>
            <tr>
                <td><strong>Web Application Support</strong></td>
                <td>No inherent support for web-specific contexts.</td>
                <td>Provides web-aware contexts like AnnotationConfigWebApplicationContext and
                    XmlWebApplicationContext.
                </td>
            </tr>
            <tr>
                <td><strong>Annotation Support</strong></td>
                <td>No. It only understands bean definitions.</td>
                <td>Yes. Full support for @Autowired, @Component, @Qualifier, etc., when used with a
                    BeanPostProcessor.
                </td>
            </tr>
            <tr>
                <td><strong>Configuration Styles</strong></td>
                <td>Primarily XML.</td>
                <td>Full support for XML, Java-based (@Configuration), and annotation-based configuration.</td>
            </tr>
            <tr>
                <td><strong>Use Case</strong></td>
                <td>In resource-constrained environments (e.g., mobile devices) where memory footprint is critical.</td>
                <td>Used in ~99.9% of all Spring applications. The standard choice for all kinds of applications.</td>
            </tr>
            </tbody>
        </table>
    </div>
    <h3>Common Implementations</h3>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Implementation</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>AnnotationConfigApplicationContext</td>
                <td>Java annotation-based config</td>
            </tr>
            <tr>
                <td>ClassPathXmlApplicationContext</td>
                <td>XML config in classpath</td>
            </tr>
            <tr>
                <td>FileSystemXmlApplicationContext</td>
                <td>XML config in file system</td>
            </tr>
            <tr>
                <td>WebApplicationContext</td>
                <td>For web applications</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>When to Use</h3>

    <ul>
        <li>Most Spring applications (default choice).</li>
        <li>Enterprise applications needing AOP, events, I18n, etc.</li>
        <li>Web applications (Spring MVC, Spring Boot).</li>
    </ul>

    <hr>
    <h2>7. Spring Bean Scopes</h2>

    <p>Spring Framework provides several bean scopes that determine the lifecycle and visibility of beans in the
        container. Understanding these scopes is crucial for proper bean management in Spring applications.</p>

    <ol>
        <li><strong>Singleton Scope (Default)</strong>

            <ul>
                <li>Definition: Only one instance per Spring IoC container</li>
                <li>Usage: Default scope if none specified</li>
                <li>Lifecycle: Created at container startup (if eager) or first request</li>
                <li>Thread Safety: Not thread-safe by default (must handle synchronization)</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(<span class="string">"singleton"</span>) <span class="comment">// or @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span>
<span class="keyword">public class</span> <span class="class">SingletonBean</span> {
    <span class="comment">// Only one instance in the entire application context</span>
}
</code>
</pre>
        </li>

        <li><strong>Prototype Scope</strong>

            <ul>
                <li>Definition: New instance created for each request</li>
                <li>Usage: For stateful beans where each caller needs a fresh instance</li>
                <li>Lifecycle: Spring doesn't manage complete lifecycle (no destroy callbacks)</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(<span class="string">"prototype"</span>) <span class="comment">// or @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span>
<span class="keyword">public class</span> <span class="class">PrototypeBean</span> {
    <span class="comment">// New instance for every getBean() call or injection</span>
}
</code>
</pre>
        </li>

        <li><strong>Web-Aware Scopes</strong>

            <p>Available only in web-aware Spring applications (Spring MVC, Spring Boot Web)</p>
        </li>

        <li><strong>Request Scope</strong>

            <ul>
                <li>Definition: One instance per HTTP request</li>
                <li>Usage: For request-specific data (e.g., user form submissions)</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(value = <span class="class">WebApplicationContext</span>.<span class="var">SCOPE_REQUEST</span>, proxyMode = <span
        class="class">ScopedProxyMode</span>.<span class="var">TARGET_CLASS</span>)
<span class="keyword">public class</span> <span class="class">RequestScopedBean</span> {
    <span class="comment">// New instance per HTTP request</span>
}
</code>
</pre>
        </li>

        <li><strong>Session Scope</strong>

            <ul>
                <li>Definition: One instance per HTTP session</li>
                <li>Usage: For user-specific data (e.g., shopping carts, user preferences)</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(value = <span class="class">WebApplicationContext</span>.<span class="var">SCOPE_SESSION</span>, proxyMode = <span
        class="class">ScopedProxyMode</span>.<span class="var">TARGET_CLASS</span>)
<span class="keyword">public class</span> <span class="class">SessionScopedBean</span> {
    <span class="comment">// Same instance throughout a user's session</span>
}
</code>
</pre>
        </li>

        <li><strong>Application Scope</strong>

            <ul>
                <li>Definition: One instance per ServletContext (similar to singleton but servlet-aware)</li>
                <li>Usage: For application-wide web components</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(value = <span class="class">WebApplicationContext</span>.<span class="var">SCOPE_APPLICATION</span>, proxyMode = <span
        class="class">ScopedProxyMode</span>.<span class="var">TARGET_CLASS</span>)
<span class="keyword">public class</span> <span class="class">ApplicationScopedBean</span> {
    <span class="comment">// Similar to singleton but web-aware</span>
}
</code>
</pre>
        </li>

        <li><strong>WebSocket Scope</strong>

            <ul>
                <li>Definition: One instance per WebSocket session</li>
                <li>Usage: In WebSocket applications for session-specific data</li>
            </ul>

            <pre class="java-code">
<code>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(scopeName = <span class="string">"websocket"</span>, proxyMode = <span
        class="class">ScopedProxyMode</span>.<span class="var">TARGET_CLASS</span>)
<span class="keyword">public class</span> <span class="class">WebSocketScopedBean</span> {
    <span class="comment">// New instance per WebSocket session</span>
}
</code>
</pre>
        </li>

        <li><strong>Custom Scopes</strong>

            <p>Spring allows creating custom scopes by implementing org.springframework.beans.factory.config.Scope</p>

            <p>Example: Creating a Thread Scope</p>

            <pre class="java-code">
<code>
<span class="keyword">public class</span> <span class="class">ThreadScope</span> <span class="keyword">implements</span> <span
        class="class">Scope</span> {
    <span class="keyword">private final</span> <span class="class">ThreadLocal</span>&lt;<span class="class">Map</span>&lt;<span
        class="class">String</span>, <span class="class">Object</span>&gt;&gt; <span class="var">threadScope</span> =
        <span class="class">ThreadLocal</span>.<span class="method">withInitial</span>(() -> <span
        class="keyword">new</span> <span class="class">HashMap</span>&lt;&gt;());

    <span class="annotation">@Override</span>
    <span class="keyword">public</span> <span class="class">Object</span> <span class="method">get</span>(<span
        class="class">String</span> <span class="var">name</span>, <span
        class="class">ObjectFactory</span>&lt;?&gt; <span class="var">objectFactory</span>) {
        <span class="class">Map</span>&lt;<span class="class">String</span>, <span class="class">Object</span>&gt; <span
        class="var">scope</span> = <span class="var">threadScope</span>.<span class="method">get</span>();
        <span class="keyword">return</span> <span class="var">scope</span>.<span
        class="method">computeIfAbsent</span>(<span class="var">name</span>, k -> <span class="var">objectFactory</span>.<span
        class="method">getObject</span>());
    }
    <span class="comment">// Implement other required methods (remove, registerDestructionCallback, etc.)</span>
}

<span class="comment">// Registering the custom scope</span>
<span class="annotation">@Configuration</span>
<span class="keyword">public class</span> <span class="class">AppConfig</span> {
    <span class="annotation">@Bean</span>
    <span class="keyword">public</span> <span class="class">CustomScopeConfigurer</span> <span class="method">customScopeConfigurer</span>() {
        <span class="class">CustomScopeConfigurer</span> <span class="var">configurer</span> = <span
        class="keyword">new</span> <span class="class">CustomScopeConfigurer</span>();
        <span class="var">configurer</span>.<span class="method">addScope</span>(<span
        class="string">"thread"</span>, <span class="keyword">new</span> <span class="class">ThreadScope</span>());
        <span class="keyword">return</span> <span class="var">configurer</span>;
    }
}

<span class="comment">// Using the custom scope</span>
<span class="annotation">@Component</span>
<span class="annotation">@Scope</span>(<span class="string">"thread"</span>)
<span class="keyword">public class</span> <span class="class">ThreadScopedBean</span> {
    <span class="comment">// New instance per thread</span>
}
</code>
</pre>
        </li>
    </ol>

    <h3>Scope Comparison Table</h3>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Scope</th>
                <th>Description</th>
                <th>Use Case</th>
                <th>Thread Safety</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Singleton</td>
                <td>One instance per container</td>
                <td>Stateless services, repositories</td>
                <td>Not thread-safe</td>
            </tr>
            <tr>
                <td>Prototype</td>
                <td>New instance each time</td>
                <td>Stateful objects, user-specific data</td>
                <td>Depends on usage</td>
            </tr>
            <tr>
                <td>Request</td>
                <td>Per HTTP request</td>
                <td>Request processing, form data</td>
                <td>Thread-confined</td>
            </tr>
            <tr>
                <td>Session</td>
                <td>Per HTTP session</td>
                <td>User sessions, shopping carts</td>
                <td>Thread-confined</td>
            </tr>
            <tr>
                <td>Application</td>
                <td>Per ServletContext</td>
                <td>Web application components</td>
                <td>Requires synchronization</td>
            </tr>
            <tr>
                <td>WebSocket</td>
                <td>Per WebSocket session</td>
                <td>Real-time messaging apps</td>
                <td>Thread-confined</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h3>Important Considerations</h3>

    <ul>
        <li><strong>Scope Inheritance</strong>: Beans inherit the scope of their configuration (unless overridden)</li>
        <li><strong>Proxy Mode</strong>: Web scopes often require proxies (ScopedProxyMode.TARGET_CLASS)</li>
        <li><strong>Memory Management</strong>: Be careful with long-lived scopes (session, application) holding large
            data
        </li>
        <li><strong>Thread Safety</strong>: Singleton beans must be designed for concurrent access</li>
    </ul>

    <hr>
    <h2>8. Bean Lifecycle in Spring Framework</h2>

    <p>Here is the complete sequence of steps for a singleton bean:</p>

    <ol>
        <li><strong>Instantiation</strong></li>
        <li><strong>Population of Properties (Dependency Injection)</strong></li>
        <li><strong>Bean Post Processing (Before Initialization)</strong>
            <ul>
                <li>BeanPostProcessor.postProcessBeforeInitialization()</li>
            </ul>
        </li>
        <li><strong>Initialization</strong>
            <ul>
                <li>Methods annotated with @PostConstruct</li>
                <li>InitializingBean.afterPropertiesSet()</li>
                <li>Custom init-method (specified via XML or @Bean(initMethod = "..."))</li>
            </ul>
        </li>
        <li><strong>Bean Post Processing (After Initialization)</strong>
            <ul>
                <li>BeanPostProcessor.postProcessAfterInitialization()</li>
            </ul>
        </li>
        <li><strong>Bean is Ready (In use in the application)</strong></li>
        <li><strong>Destruction</strong>
            <ul>
                <li>Methods annotated with @PreDestroy</li>
                <li>DisposableBean.destroy()</li>
                <li>Custom destroy-method (specified via XML or @Bean(destroyMethod = "..."))</li>
            </ul>
        </li>
    </ol>

    <h3>The Main Bean (MyService)</h3>

    <p>This bean uses all three ways to define init and destroy methods, and implements the *Aware interfaces for
        context details.</p>

    <pre class="java-code">
<code>
<span class="keyword">import</span> org.springframework.beans.BeansException;
<span class="keyword">import</span> org.springframework.beans.factory.*;
<span class="keyword">import</span> org.springframework.context.*;
<span class="keyword">import</span> javax.annotation.PostConstruct;
<span class="keyword">import</span> javax.annotation.PreDestroy;

<span class="keyword">public class</span> <span class="class">MyService</span> <span class="keyword">implements</span> InitializingBean, DisposableBean, ApplicationContextAware, BeanNameAware {
    <span class="keyword">private</span> String message;

    <span class="comment">// 1. Constructor (Instantiation)</span>
    <span class="keyword">public</span> MyService() {
        System.out.println(<span class="string">"1. [CONSTRUCTOR] Bean Instantiated."</span>);
    }

    <span class="comment">// 2. Setter Injection (Population of Properties)</span>
    <span class="keyword">public</span> <span class="keyword">void</span> setMessage(String message) {
        <span class="keyword">this</span>.message = message;
        System.out.println(<span class="string">"2. [DI] Properties Populated. Message: "</span> + message);
    }

    <span class="comment">// 3. BeanNameAware callback</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> setBeanName(String name) {
        System.out.println(<span
        class="string">"3. [AWARE INTERFACE] BeanNameAware: Bean name is '"</span> + name + <span
        class="string">"'"</span>);
    }

    <span class="comment">// 4. ApplicationContextAware callback</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> setApplicationContext(ApplicationContext applicationContext) <span
        class="keyword">throws</span> BeansException {
        System.out.println(<span class="string">"4. [AWARE INTERFACE] ApplicationContextAware: Context loaded."</span>);
    }

    <span class="comment">// 5. @PostConstruct (Initialization)</span>
    @PostConstruct
    <span class="keyword">public</span> <span class="keyword">void</span> postConstruct() {
        System.out.println(<span class="string">"5. [INIT] @PostConstruct method called."</span>);
    }

    <span class="comment">// 6. InitializingBean (Initialization)</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> afterPropertiesSet() <span class="keyword">throws</span> Exception {
        System.out.println(<span class="string">"6. [INIT] InitializingBean.afterPropertiesSet() called."</span>);
    }

    <span class="comment">// 7. Custom init method (Initialization)</span>
    <span class="keyword">public</span> <span class="keyword">void</span> myInit() {
        System.out.println(<span class="string">"7. [INIT] Custom init-method called."</span>);
    }

    <span class="comment">// Business method</span>
    <span class="keyword">public</span> <span class="keyword">void</span> performTask() {
        System.out.println(<span class="string">"8. [BUSINESS] Bean is in use. Performing task: "</span> + message);
    }

    <span class="comment">// 9. @PreDestroy (Destruction)</span>
    @PreDestroy
    <span class="keyword">public</span> <span class="keyword">void</span> preDestroy() {
        System.out.println(<span class="string">"9. [DESTROY] @PreDestroy method called."</span>);
    }

    <span class="comment">// 10. DisposableBean (Destruction)</span>
    @Override
    <span class="keyword">public</span> <span class="keyword">void</span> destroy() <span class="keyword">throws</span> Exception {
        System.out.println(<span class="string">"10. [DESTROY] DisposableBean.destroy() called."</span>);
    }

    <span class="comment">// 11. Custom destroy method (Destruction)</span>
    <span class="keyword">public</span> <span class="keyword">void</span> myCleanup() {
        System.out.println(<span class="string">"11. [DESTROY] Custom destroy-method called."</span>);
    }
}
</code>
    </pre>

    <h3>A Custom BeanPostProcessor</h3>

    <p>This is crucial to see the before/after initialization phases.</p>

    <pre class="java-code">
<code>
<span class="keyword">import</span> org.springframework.beans.BeansException;
<span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;
<span class="keyword">import</span> org.springframework.stereotype.Component;

@Component
<span class="keyword">public class</span> <span class="class">MyBeanPostProcessor</span> <span class="keyword">implements</span> BeanPostProcessor {
    @Override
    <span class="keyword">public</span> Object postProcessBeforeInitialization(Object bean, String beanName) <span
        class="keyword">throws</span> BeansException {
        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyService) {
            System.out.println(<span
        class="string">">> [BEAN POST PROCESSOR] postProcessBeforeInitialization() for: "</span> + beanName);
        }
        <span class="keyword">return</span> bean;
    }

    @Override
    <span class="keyword">public</span> Object postProcessAfterInitialization(Object bean, String beanName) <span
        class="keyword">throws</span> BeansException {
        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyService) {
            System.out.println(<span
        class="string">"<< [BEAN POST PROCESSOR] postProcessAfterInitialization() for: "</span> + beanName);
        }
        <span class="keyword">return</span> bean;
    }
}
</code>
    </pre>

    <h3>Java Configuration Class (AppConfig)</h3>

    <p>We define our bean here, specifying the custom init-method and destroy-method.</p>

    <pre class="java-code">
<code>
<span class="keyword">import</span> org.springframework.context.annotation.Bean;
<span class="keyword">import</span> org.springframework.context.annotation.Configuration;

@Configuration
<span class="keyword">public class</span> <span class="class">AppConfig</span> {
    @Bean(initMethod = <span class="string">"myInit"</span>, destroyMethod = <span class="string">"myCleanup"</span>)
    <span class="keyword">public</span> MyService myService() {
        MyService myService = <span class="keyword">new</span> MyService();
        myService.setMessage(<span class="string">"Hello, Spring Lifecycle!"</span>);
        <span class="keyword">return</span> myService;
    }
}
</code>
    </pre>

    <h3>Main Application to Run the Example</h3>

    <pre class="java-code">
<code>
<span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;

<span class="keyword">public class</span> <span class="class">LifecycleDemoApplication</span> {
    <span class="keyword">public static</span> <span class="keyword">void</span> main(String[] args) {
        <span class="comment">// Create the Spring context (This triggers bean creation)</span>
        System.out.println(<span class="string">"-- Step: Creating ApplicationContext --"</span>);
        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);

        <span class="comment">// Retrieve the bean and use it</span>
        System.out.println(<span class="string">"\n-- Step: Retrieving Bean --"</span>);
        MyService service = context.getBean(MyService.class);
        service.performTask();

        <span class="comment">// Close the context (This triggers bean destruction)</span>
        System.out.println(<span class="string">"\n-- Step: Closing ApplicationContext --"</span>);
        context.close(); <span class="comment">// or context.registerShutdownHook();</span>
    }
}
</code>
    </pre>

    <h3>Expected Output (The Exact Sequence)</h3>

    <p>When you run the LifecycleDemoApplication, you will see the following output, which clearly shows the lifecycle
        sequence:</p>

    <pre class="code-block">
<code>
-- Step: Creating ApplicationContext --
1. [CONSTRUCTOR] Bean Instantiated.
2. [DI] Properties Populated. Message: Hello, Spring Lifecycle!
3. [AWARE INTERFACE] BeanNameAware: Bean name is 'myService'
4. [AWARE INTERFACE] ApplicationContextAware: Context loaded.
>> [BEAN POST PROCESSOR] postProcessBeforeInitialization() for: myService
5. [INIT] @PostConstruct method called.
6. [INIT] InitializingBean.afterPropertiesSet() called.
7. [INIT] Custom init-method called.
<< [BEAN POST PROCESSOR] postProcessAfterInitialization() for: myService

-- Step: Retrieving Bean --
8. [BUSINESS] Bean is in use. Performing task: Hello, Spring Lifecycle!

-- Step: Closing ApplicationContext --
9. [DESTROY] @PreDestroy method called.
10. [DESTROY] DisposableBean.destroy() called.
11. [DESTROY] Custom destroy-method called.
</code>
    </pre>
    <h2>Bean Lifecycle Overview</h2>

    <table class="basic-table">
        <thead>
        <tr>
            <th width="20%">Phase</th>
            <th width="30%">Methods / Callbacks</th>
            <th width="30%">Implementation Method</th>
            <th width="20%">Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">Before Bean Instantiation</td>
        </tr>
        <tr>
            <td>Bean Definition Loading</td>
            <td>BeanFactoryPostProcessor.postProcessBeanFactory()</td>
            <td>Implement BeanFactoryPostProcessor interface</td>
            <td>Modifies bean definitions before beans are created</td>
        </tr>
        <tr>
            <td>Custom Bean Validation</td>
            <td>Custom validation methods</td>
            <td>Custom implementation</td>
            <td>Custom validation logic before bean creation</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">Bean Instantiation</td>
        </tr>
        <tr>
            <td>Object Instantiation</td>
            <td>Constructor</td>
            <td>Class constructor</td>
            <td>Creates the bean instance</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">After Instantiation (Before
                Initialization)
            </td>
        </tr>
        <tr>
            <td>Dependency Injection</td>
            <td>Setter methods, @Autowired</td>
            <td>Setter methods or field injection</td>
            <td>Dependencies are injected into the bean</td>
        </tr>
        <tr>
            <td>Aware Interfaces</td>
            <td>BeanNameAware.setBeanName()
                BeanFactoryAware.setBeanFactory()
                ApplicationContextAware.setApplicationContext()
                etc.
            </td>
            <td>Implement relevant *Aware interface</td>
            <td>Provides access to container facilities</td>
        </tr>
        <tr>
            <td>Bean Post Processing (Before Init)</td>
            <td>BeanPostProcessor.postProcessBeforeInitialization()</td>
            <td>Implement BeanPostProcessor interface</td>
            <td>Custom modification of bean instances before init</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">Initialization Phase</td>
        </tr>
        <tr>
            <td>Initialization</td>
            <td>@PostConstruct annotated method</td>
            <td>Annotate method with @PostConstruct</td>
            <td>JSR-250 standard initialization method</td>
        </tr>
        <tr>
            <td>Initialization</td>
            <td>InitializingBean.afterPropertiesSet()</td>
            <td>Implement InitializingBean interface</td>
            <td>Spring-specific initialization callback</td>
        </tr>
        <tr>
            <td>Initialization</td>
            <td>Custom init method</td>
            <td>XML: init-method attribute
                Java: @Bean(initMethod = "...")
            </td>
            <td>Custom initialization method defined in configuration</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">After Initialization</td>
        </tr>
        <tr>
            <td>Bean Post Processing (After Init)</td>
            <td>BeanPostProcessor.postProcessAfterInitialization()</td>
            <td>Implement BeanPostProcessor interface</td>
            <td>Custom modification of bean instances after init</td>
        </tr>
        <tr>
            <td>Bean Ready</td>
            <td>-</td>
            <td>-</td>
            <td>Bean is fully configured and ready for use</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">Before Destruction</td>
        </tr>
        <tr>
            <td>Container Shutdown Initiated</td>
            <td>Context close event</td>
            <td>context.close() or context.registerShutdownHook()</td>
            <td>Container begins shutdown process</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">Destruction Phase</td>
        </tr>
        <tr>
            <td>Destruction</td>
            <td>@PreDestroy annotated method</td>
            <td>Annotate method with @PreDestroy</td>
            <td>JSR-250 standard destruction method</td>
        </tr>
        <tr>
            <td>Destruction</td>
            <td>DisposableBean.destroy()</td>
            <td>Implement DisposableBean interface</td>
            <td>Spring-specific destruction callback</td>
        </tr>
        <tr>
            <td>Destruction</td>
            <td>Custom destroy method</td>
            <td>XML: destroy-method attribute
                Java: @Bean(destroyMethod = "...")
            </td>
            <td>Custom destruction method defined in configuration</td>
        </tr>

        <tr>
            <td style="text-align: center !important;" class="phase-header" colspan="4">After Destruction</td>
        </tr>
        <tr>
            <td>Garbage Collection</td>
            <td>finalize() (not recommended)</td>
            <td>Override Object.finalize()</td>
            <td>Called by garbage collector before object destruction (avoid using)</td>
        </tr>
        </tbody>
    </table>

    <hr>

    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../spring/intro.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../spring/mvc.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>