<!DOCTYPE html>
<html lang="en">
<head>
    <title>Architecture</title>

    <!-- Stylesheet -->
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="ms">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">â˜°</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="intro.html">microservices</a>
        <span class="separator">/</span>
        <a href="#">Architecture</a>
    </div>
</nav>
<!-- Components will be inserted here by components.js -->

<!-- Main Content Section -->
<main id="content">
    <h2>1. Microservices Architecture</h2>

    <img src="../js/images/ms/arc.png" class="responsive-img">
    <hr>
    <h2>2. Microservices Components</h2>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Service</th>
                <th>Dependency</th>
                <th>Properties</th>
                <th>Annotations</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Eureka Server</td>
                <td>spring-cloud-starter-netflix-eureka-server</td>
                <td>eureka: client: register-with-eureka: false fetch-registry: false</td>
                <td>@EnableEurekaServer</td>
            </tr>
            <tr>
                <td>Eureka Client</td>
                <td>spring-cloud-starter-netflix-eureka-client</td>
                <td>eureka: client: service-url: defaultZone: http://localhost:8761/eureka</td>
                <td></td>
            </tr>
            <tr>
                <td>Config Server</td>
                <td>spring-cloud-config-server</td>
                <td>spring: cloud: config: server: git: url: &lt;YOUR_GIT_REPO_URL_HERE &gt; clone-on-start: true</td>
                <td>@EnableConfigServer</td>
            </tr>
            <tr>
                <td>Config Client</td>
                <td>spring-cloud-starter-config</td>
                <td>spring: config: import: optionai.configserver:http://localhost:8888</td>
                <td></td>
            </tr>
            <tr>
                <td>API Gateway</td>
                <td>spring-cloud-starter-gateway</td>
                <td>spring: cloud: gateway: discovery: locator: enabled: true lower-case-service-id: true routes: - id:
                    products url: lb://product-service predicates: - Path=/products/** filters: -
                    AddRequestHeader=X-Request-Gateway, API-GW
                </td>
                <td></td>
            </tr>
            <tr>
                <td>Resilience4</td>
                <td>resilience4j-spring-boot3</td>
                <td>resilience4j: circuitbreaker: instances: userService: register-health-indicator: true
                    sliding-window-size: 5 minimum-number-of-calls: 3 failure-rate-threshold: 50
                    wait-duration-in-open-state: 5s retry: instances: userService: max-attempts: 3 wait-duration: 2s
                    timelimiter: instances: userService: timeout-duration: 2s
                </td>
                <td>@CircuitBreaker(name = "userService", fallbackMethod = "fallbackUser") @Retry(name = "userService")
                    @TimeLimiter(name = "userService", fallbackMethod = "fallbackUserFuture")
                </td>
            </tr>
            <tr>
                <td>Zipkin and Sleuth</td>
                <td>spring-cloud-starter-zipkin spring-cloud-starter-sleuth</td>
                <td>spring.zipkin.base-url=http://localhost:9411/</td>
                <td>@EnableSleuth</td>
            </tr>
            <tr>
                <td>Feign client</td>
                <td>spring-cloud-starter-openfeign</td>
                <td>feign: client: config: default: connectTimeout: 5000 readTimeout: 5000 loggerLevel: full</td>
                <td>@EnableFeignClients @FeignClient(value = "DEPARTMENT-SERVICE", url = "http://localhost:8080") public
                    interface APIClient { @GetMapping(value = "/api/departments/{id}") @DepartmentDto
                    getDepartmentById(@PathVariable({ "id"}) Long departmentId); }
                </td>
            </tr>
            </tbody>
        </table>
    </div>
    <hr>
    <h2>3. Differences between RestTemplate , WebClient and Feign Client</h2>

    <h4>1. RestTemplate (Legacy)</h4>

    <ul>
        <li><strong>Type</strong>: Synchronous, blocking HTTP client (Spring Web module).</li>
        <li><strong>Thread Model</strong>: Uses one thread per request, which can lead to thread exhaustion under high
            load.
        </li>
        <li><strong>Usage</strong>: Works with traditional Spring MVC applications but is now
            <strong>deprecated</strong> in Spring 5+.
        </li>
    </ul>

    <ul>
        <li><strong>Pros</strong>:
            <ul>
                <li>Simple for basic HTTP calls.</li>
                <li>Well-documented and widely used in older applications.</li>
            </ul>
        </li>

        <li><strong>Cons</strong>:
            <ul>
                <li>Poor scalability (blocks threads while waiting for responses).</li>
                <li>No support for reactive programming or HTTP/2.</li>
                <li>Requires manual URI construction and error handling.</li>
            </ul>
        </li>

        <li><strong>Example</strong>:
            <pre class="java-code">
<code>
<span class="class">String</span> <span class="var">response</span> = <span class="var">restTemplate</span>.getForObject(<span
        class="string">"http://example.com/api"</span>, <span class="class">String</span>.class);
</code>
</pre>
        </li>
    </ul>

    <hr>

    <h4>2. WebClient (Modern)</h4>

    <ul>
        <li><strong>Type</strong>: Asynchronous, non-blocking HTTP client (Spring WebFlux module).</li>
        <li><strong>Thread Model</strong>: Uses event-loop (Netty-based) for high concurrency with minimal threads.</li>
        <li><strong>Usage</strong>: Ideal for reactive applications (Spring WebFlux) and high-performance systems.</li>
    </ul>

    <ul>
        <li><strong>Pros</strong>:
            <ul>
                <li>Supports reactive streams ( Mono / Flux ).</li>
                <li>High scalability (handles thousands of concurrent requests efficiently).</li>
                <li>Native HTTP/2 support.</li>
                <li>Fluent API for chaining requests.</li>
            </ul>
        </li>

        <li><strong>Cons</strong>:
            <ul>
                <li>Requires understanding of reactive programming.</li>
                <li>Not declarative (unlike Feign).</li>
            </ul>
        </li>

        <li><strong>Example</strong>:
            <pre class="java-code">
<code>
<span class="class">Mono</span>&lt;<span class="class">String</span>&gt; <span class="var">response</span> = <span
        class="var">webClient</span>.get()
.uri(<span class="string">"http://example.com/api"</span>)
.retrieve()
.bodyToMono(<span class="class">String</span>.class);
</code>
</pre>
        </li>
    </ul>

    <hr>

    <h4>3. Feign Client (Declarative)</h4>

    <ul>
        <li><strong>Type</strong>: Declarative HTTP client (Spring Cloud OpenFeign).</li>
        <li><strong>Thread Model</strong>: Depends on the underlying client (can integrate with WebClient for
            non-blocking calls).
        </li>
        <li><strong>Usage</strong>: Best for microservices with Spring Cloud (load balancing, service discovery).</li>
    </ul>

    <ul>
        <li><strong>Pros</strong>:
            <ul>
                <li><strong>Declarative style</strong> (define interfaces with annotations).</li>
                <li>Integrates with <strong>Spring Cloud</strong> (Eureka, Circuit Breakers, Retry).</li>
            </ul>
        </li>
    </ul>

    <ul>
        <li>Built-in load balancing (via Spring Cloud LoadBalancer).</li>
        <li>Simplifies REST client code.</li>
    </ul>

    <p><strong>Cons:</strong></p>
    <ul>
        <li>Requires Spring Cloud dependencies.</li>
        <li>Less control over low-level HTTP settings.</li>
    </ul>

    <p><strong>Example:</strong></p>

    <pre class="java-code">
<code>
<span class="annotation">@FeignClient</span>(name = <span class="string">"example-service"</span>)
<span class="keyword">public interface</span> <span class="class">ExampleClient</span> {
    <span class="annotation">@GetMapping</span>(<span class="string">"/api"</span>)
    <span class="class">String</span> <span class="method">fetchData</span>();
}
</code>
</pre>

    <hr>

    <h2>Key Differences Summary</h2>

    <h4>1. Blocking vs. Non-blocking:</h4>
    <ul>
        <li><strong>RestTemplate</strong> blocks threads.</li>
        <li><strong>WebClient</strong> is fully non-blocking.</li>
        <li><strong>Feign</strong> can be either (depends on configuration).</li>
    </ul>

    <h4>2. Programming Model:</h4>
    <ul>
        <li><strong>RestTemplate</strong>: Imperative.</li>
        <li><strong>WebClient</strong>: Reactive (Flux/Mono).</li>
        <li><strong>Feign</strong>: Declarative (interface-based).</li>
    </ul>

    <h4>3. Use Cases:</h4>
    <ul>
        <li><strong>RestTemplate</strong>: Legacy apps (avoid in new projects).</li>
        <li><strong>WebClient</strong>: Modern, high-performance systems.</li>
        <li><strong>Feign</strong>: Microservices with Spring Cloud.</li>
    </ul>

    <h4>4. Advanced Features:</h4>
    <ul>
        <li><strong>Feign</strong> supports load balancing, retries, and circuit breakers out of the box.</li>
        <li><strong>WebClient</strong> supports streaming (e.g., Server-Sent Events).</li>
        <li><strong>RestTemplate</strong> has no built-in resilience features.</li>
    </ul>

    <hr>

    <h2>Which One to Choose?</h2>

    <ul>
        <li>For <strong>new Spring Boot 3+ applications</strong>, prefer <strong>WebClient</strong> (non-blocking,
            future-proof).
        </li>
        <li>For <strong>microservices with Spring Cloud</strong>, use <strong>Feign</strong> (declarative +
            integrations).
        </li>
        <li><strong>RestTemplate</strong> should only be used for maintaining older applications.</li>
    </ul>

    <p>All three can coexist in the same project, but <strong>WebClient is the recommended default</strong> for most
        cases.</p>
    <hr>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../ms/intro.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../ms/registry-discovery.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>
<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>