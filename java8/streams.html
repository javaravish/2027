<!DOCTYPE html>
<html lang="en">
<head>
    <title>Streams</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="java8">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">â˜°</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="#">Java 8</a>
        <span class="separator">/</span>
        <a href="#">Introduction</a>
    </div>
</nav>

<!-- Header will be inserted by JavaScript -->

<!-- Sidebar will be inserted by JavaScript -->

<!-- Main Content Section -->
<main id="content">
    <h2>Java 8 Streams</h2>

    <h3>1) What Are Streams?</h3>
    <p>Streams can be defined as a sequences of elements from a source which support data processing operations. You can treat streams as operations on data. You will get to know as you go through this article.</p>

    <h3>2) Why Streams?</h3>
    <p>Almost every Java application use Collections API to store and process the data. Despite being the most used Java API, it is not easy to write the code for even some common data processing operations like filtering, finding, matching, sorting, mapping etc using Collections API . So, there needed Next-Gen API to process the data. So Java API designers have come with Java 8 Streams API to write more complex data processing operations with much of ease.</p>

    <h3>3) Characteristics Of Java 8 Streams</h3>

    <h4>3.1) Streams are not the data structures</h4>
    <p>Streams doesn't store the data. You can't add or remove elements from streams. Hence, they are not the data structures. They are the just operations on data.</p>

    <h4>3.2) Stream Consumes a data source</h4>
    <p>Stream consumes a source, performs operations on it and produces the result. Source may be a collection or an array or an I/O resource. Remember, stream doesn't modify the source.</p>

    <h4>3.3) Intermediate And Terminal Operations</h4>
    <p>Most of the stream operations return another new stream and they can be chained together to form a pipeline of operations.</p>
    <p>The operations which return stream themselves are called intermediate operations. For example - <strong>filter(), distinct(), sorted()</strong> etc.</p>
    <p>The operations which return other than stream are called terminal operations. <strong>count(). min(), max()</strong> are some terminal operations.</p>

    <h2>2. Java 8 Stream Intermediate Vs Terminal Operations</h2>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Intermediate Operations</th>
                <th>Terminal Operations</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>They return stream.</td>
                <td>They return non-stream values.</td>
            </tr>
            <tr>
                <td>They can be chained together to form a pipeline of operations.</td>
                <td>They can't be chained together.</td>
            </tr>
            <tr>
                <td>Pipeline of operations may contain any number of intermediate operations.</td>
                <td>Pipeline of operations can have maximum one terminal operation, that too at the end.</td>
            </tr>
            <tr>
                <td>Intermediate operations are lazily loaded.</td>
                <td>Terminal operations are eagerly loaded.</td>
            </tr>
            <tr>
                <td>They don't produce end result.</td>
                <td>They produce end result.</td>
            </tr>
            <tr>
                <td>Examples : filter(), map(), distinct(), sorted(), limit(), skip()</td>
                <td>Examples : forEach(), toArray(), reduce(), collect(), min(), max(), count(), anyMatch(), allMatch(), noneMatch(), findFirst(), findAny()</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h4>3.4) Pipeline Of Operations</h4>
    <p>A pipeline of operations consists of three things - a source, one or more intermediate operations and a terminal operation. Pipe-lining of operations let you to write database-like queries on a data source. In the below example, int array is the source, filter() and distinct() are intermediate operations and forEach() is a terminal operation.</p>

    <pre class="java-code">
<code><span class="comment">// Java code example</span>
IntStream.of(<span class="keyword">new</span> <span class="class">int</span>[] {<span class="number">4</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">7</span>}).filter((<span class="class">int</span> i) -> i > <span class="number">5</span>).distinct().forEach(System.out::println);</code>
    </pre>

    <h4>3.5 Internal Iteration</h4>
    <p>Collections need to be iterated explicitly. i.e you have to write the code to iterate over collections. But, all stream operations do the iteration internally behind the scene for you. You need not to worry about iteration at all while writing the code using Java 8 Streams API.</p>

    <h4>3.6 Parallel Execution</h4>
    <p>To gain the performance while processing the large amount of data, you have to process it in parallel and use multi core architectures. Java 8 Streams can be processed in parallel without writing any multi threaded code. For example, to process the collections in parallel, you just use parallelStream() method instead of stream() method.</p>

    <pre class="java-code">
<code><span class="comment">// Java code example</span>
<span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
<span class="comment">//Normal Execution</span>
names.stream().filter((<span class="class">String</span> name) -> name.length() > <span class="number">5</span>)
.skip(<span class="number">2</span>).forEach(System.out::println);
<span class="comment">//Parallel Execution</span>
names.parallelStream().filter((<span class="class">String</span> name) -> name.length() > <span class="number">5</span>)
.skip(<span class="number">2</span>).forEach(System.out::println);</code>
    </pre>

    <h4>3.7 Streams are lazily populated</h4>
    <p>All elements of a stream are not populated at a time. They are lazily populated as per demand because intermediate operations are not evaluated until terminal operation is invoked.</p>

    <h4>3.8 Streams are traversable only once</h4>
    <p>You can't traverse the streams more than once just like iterators. If you traverse the stream first time, it is said to be consumed.</p>

    <pre class="java-code">
<code><span class="comment">// Java code example</span>
<span class="class">List</span>&lt;<span class="class">String</span>> nameList = <span class="class">Arrays</span>.asList(<span class="string">"Dinesh"</span>, <span class="string">"Ross"</span>, <span class="string">"Kagiso"</span>, <span class="string">"Steyn"</span>);
<span class="class">Stream</span>&lt;<span class="class">String</span>> stream = nameList.stream();
stream.forEach(System.out::println);
stream.forEach(System.out::println);
<span class="comment">//Error : stream has already been operated upon or closed</span></code>
    </pre>

    <h4>3.9) Short Circuiting Operations</h4>
    <p>Short circuiting operations are the operations which don't need the whole stream to be processed to produce a result. For example - findFirst(), findAny(), limit() etc.</p>
    <img src="../js/images/Java/streams.png" class="responsive-img">
    <h3>4) java.util.stream.Stream</h3>
    <p>java.util.stream.Stream interface is the center of Java 8 Streams API. This interface contains all the stream operations. Below table shows frequently used Stream methods with description.</p>

    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Operation</th>
                <th>Method Signature</th>
                <th>Type Of Operation</th>
                <th>What It Does?</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>filter()</td>
                <td>Stream&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</td>
                <td>Intermediate</td>
                <td>Returns a stream of elements which satisfy the given predicate.</td>
            </tr>
            <tr>
                <td>map()</td>
                <td>Stream&lt;R&gt; map(Function&lt;T, R&gt; mapper)</td>
                <td>Intermediate</td>
                <td>Returns a stream consisting of results after applying given function to elements of the stream.</td>
            </tr>
            <tr>
                <td>distinct()</td>
                <td>Stream&lt;T&gt; distinct()</td>
                <td>Intermediate</td>
                <td>Returns a stream of unique elements.</td>
            </tr>
            <tr>
                <td>sorted()</td>
                <td>Stream&lt;T&gt; sorted()</td>
                <td>Intermediate</td>
                <td>Returns a stream consisting of elements sorted according to natural order.</td>
            </tr>
            <tr>
                <td>limit()</td>
                <td>Stream&lt;T&gt; limit(long maxSize)</td>
                <td>Intermediate</td>
                <td>Returns a stream containing first n elements.</td>
            </tr>
            <tr>
                <td>skip()</td>
                <td>Stream&lt;T&gt; skip(long n)</td>
                <td>Intermediate</td>
                <td>Returns a stream after skipping first n elements.</td>
            </tr>
            <tr>
                <td>forEach()</td>
                <td>void forEach(Consumer&lt;T&gt; action)</td>
                <td>Terminal</td>
                <td>Performs an action on all elements of a stream.</td>
            </tr>
            <tr>
                <td>toArray()</td>
                <td>Object[] toArray()</td>
                <td>Terminal</td>
                <td>Returns an array containing elements of a stream.</td>
            </tr>
            <tr>
                <td>reduce()</td>
                <td>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td>
                <td>Terminal</td>
                <td>Performs reduction operation on elements of a stream using initial value and binary operation.</td>
            </tr>
            <tr>
                <td>collect()</td>
                <td>R collect(Collector&lt;T&gt; collector)</td>
                <td>Terminal</td>
                <td>Returns mutable result container such as List or Set.</td>
            </tr>
            <tr>
                <td>min()</td>
                <td>Optional&lt;T&gt; min(Comparator&lt;T&gt; comparator)</td>
                <td>Terminal</td>
                <td>Returns minimum element in a stream wrapped in an Optional object.</td>
            </tr>
            <tr>
                <td>max()</td>
                <td>Optional&lt;T&gt; max(Comparator&lt;T&gt; comparator)</td>
                <td>Terminal</td>
                <td>Returns maximum element in a stream</td>
            </tr>
            <tr>
                <td>count()</td>
                <td>long count()</td>
                <td>Terminal</td>
                <td>Returns the number of elements in a stream.</td>
            </tr>
            <tr>
                <td>anyMatch()</td>
                <td>boolean anyMatch(Predicate&lt;T&gt; predicate)</td>
                <td>Terminal</td>
                <td>Returns true if any one element of a stream matches with given predicate.</td>
            </tr>
            <tr>
                <td>allMatch()</td>
                <td>boolean allMatch(Predicate&lt;T&gt; predicate)</td>
                <td>Terminal</td>
                <td>Returns true if all the elements of a stream matches with given predicate.</td>
            </tr>
            <tr>
                <td>noneMatch()</td>
                <td>boolean noneMatch(Predicate&lt;T&gt; predicate)</td>
                <td>Terminal</td>
                <td>Returns true only if all the elements of a stream doesn't match with given predicate.</td>
            </tr>
            <tr>
                <td>findFirst()</td>
                <td>Optional&lt;T&gt; findFirst()</td>
                <td>Terminal</td>
                <td>Returns first element of a stream wrapped in an Optional object.</td>
            </tr>
            <tr>
                <td>findAny()</td>
                <td>Optional&lt;T&gt; findAny()</td>
                <td>Terminal</td>
                <td>Randomly returns any one element in a stream.</td>
            </tr>
            </tbody>
        </table>
    </div>

    <h2>5) Java 8 Stream Operations</h2>
    <p>Let's see some important stream operations with examples.</p>

    <h3>5.1) Stream Creation Operations</h3>

    <h4>5.1.1) empty(): Creates an empty stream</h4>
    <p>Method Signature : public static&lt;T&gt; Stream&lt;T&gt; empty()</p>
    <p>Type Of Method : Static Method</p>
    <p>What It Does? : Returns an empty stream of type T.</p>

    <pre class="java-code">
<code><span class="class">Stream</span>&lt;<span class="class">String</span>> emptyStream = <span class="class">Stream</span>.empty();
System.out.println(emptyStream.count());

<span class="comment">//Output : 0</span></code>
    </pre>

    <h4>5.1.2) of(T t): Creates a stream of single element of type T</h4>
    <p>Method Signature : public static&lt;T&gt; Stream&lt;T&gt; of(T t)</p>
    <p>Type Of Method : Static Method</p>
    <p>What It Does? : Returns a single element stream of type T.</p>

    <pre class="java-code">
<code><span class="class">Stream</span>&lt;<span class="class">Student</span>> singleElementStream = <span class="class">Stream</span>.of(<span class="keyword">new</span> <span class="class">Student</span>());
System.out.println(singleElementStream.count());

<span class="comment">//Output : 1</span></code>
    </pre>

    <h4>5.1.3) of(T... values): Creates a stream from values</h4>
    <p>Method Signature : public static&lt;T&gt; Stream&lt;T&gt; of(T... values)</p>
    <p>Type Of Method : Static Method</p>
    <p>What it does? : Returns a stream consisting of supplied values as elements.</p>

    <pre class="java-code">
<code><span class="class">Stream</span>&lt;<span class="class">Integer</span>> streamOfNumbers = <span class="class">Stream</span>.of(<span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>);
System.out.println(streamOfNumbers.count());

<span class="comment">//Output : 7</span></code>
    </pre>

    <h4>5.1.4) Creating streams from collections</h4>
    <p>From Java 8, every collection type will have a method called stream() which returns the stream of respective collection type.</p>
    <p>Example : Creating a stream from List</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> listOfStrings = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
listOfStrings.add(<span class="string">"One"</span>);
listOfStrings.add(<span class="string">"Two"</span>);
listOfStrings.add(<span class="string">"Three"</span>);
listOfStrings.stream().forEach(System.out::println);
<span class="comment">// Output :</span>
<span class="comment">// One</span>
<span class="comment">// Two</span>
<span class="comment">// Three</span></code>
    </pre>

    <h3>5.2 Selection Operations</h3>

    <h4>5.2.1 filter(): Selecting with a predicate</h4>
    <p>Method Signature : Stream&lt;T&gt; filter(Predicate&lt;T&gt; predicate)</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What it does? : Returns a stream of elements which satisfy the given predicate.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
<span class="comment">//Selecting names containing more than 5 characters</span>
names.stream().filter((<span class="class">String</span> name) -> name.length() > <span class="number">5</span>).forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// Johnson</span>
<span class="comment">// Samontika</span>
<span class="comment">// Brijesh</span></code>
    </pre>

    <h4>5.2.2 distinct(): Selects only unique elements</h4>
    <p>Method Signature : Stream&lt;T&gt; distinct()</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream of unique elements.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Brijesh"</span>);
<span class="comment">//Selecting only unique names</span>
names.stream().distinct().forEach(System.out::println);
<span class="comment">// Output :</span>
<span class="comment">// David</span>
<span class="comment">// Johnson</span>
<span class="comment">// Samontika</span>
<span class="comment">// Brijesh</span>
<span class="comment">// John</span></code>
    </pre>

    <h4>5.2.3) limit(): Selects first n elements</h4>
    <p>Method Signature : Stream&lt;T&gt; limit(long maxSize)</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream containing first n elements.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Brijesh"</span>);
<span class="comment">// Selecting first 4 names</span>
names.stream().limit(<span class="number">4</span>).forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// David</span>
<span class="comment">// Johnson</span>
<span class="comment">// Samontika</span>
<span class="comment">// Brijesh</span></code>
    </pre>

    <h4>5.2.4) skip() : Skips first n elements</h4>
    <p>Method Signature : Stream&lt;T&gt; skip(long n)</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream after skipping first n elements.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Brijesh"</span>);
<span class="comment">// Skipping first 4 names</span>
names.stream().skip(<span class="number">4</span>).forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// John</span>
<span class="comment">// David</span>
<span class="comment">// Brijesh</span></code>
    </pre>

    <h3>5.3) Mapping Operations</h3>

    <h4>5.3.1) map() : Applies a function</h4>
    <p>Method Signature : Stream&lt;R&gt; map(Function&lt;T, R&gt; mapper);</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream consisting of results after applying given function to elements of the stream.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
<span class="comment">//Returns length of each name</span>
names.stream().map(<span class="class">String</span>::length).forEach(System.out::println);
<span class="comment">// Output :</span>
<span class="comment">// 5</span>
<span class="comment">// 7</span>
<span class="comment">// 9</span>
<span class="comment">// 7</span>
<span class="comment">// 4</span></code>
    </pre>

    <p>Other versions of map() method : mapToInt(), mapToLong() and mapToDouble().</p>

    <h3>5.4) Sorting Operations</h3>

    <h4>5.4.1 sorted(): Sorting according to natural order</h4>
    <p>Method Signature : Stream&lt;T&gt; sorted()</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream consisting of elements sorted according to natural order.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
<span class="comment">//Sorting the names according to natural order</span>
names.stream().sorted().forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// Brijesh</span>
<span class="comment">// David</span>
<span class="comment">// John</span>
<span class="comment">// Johnson</span>
<span class="comment">// Samontika</span></code>
    </pre>

    <h4>5.4.2 sorted(Comparator): Sorting according to supplied comparator</h4>
    <p>Method Signature : Stream&lt;T&gt; sorted(Comparator&lt;T&gt; comparator)</p>
    <p>Type Of Operation : Intermediate Operation</p>
    <p>What It Does? : Returns a stream consisting of elements sorted according to supplied comparator.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);
<span class="comment">//Sorting the names according to their length</span>
names.stream().sorted((<span class="class">String</span> name1, <span class="class">String</span> name2) -> name1.length() - name2.length()).forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// John</span>
<span class="comment">// David</span>
<span class="comment">// Johnson</span>
<span class="comment">// Brijesh</span>
<span class="comment">// Samontika</span></code>
    </pre>

    <h3>5.5) Reducing Operations</h3>
    <p>Reducing operations are the operations which combine all the elements of a stream repeatedly to produce a single value. For example, counting number of elements, calculating average of elements, finding maximum or minimum of elements etc.</p>

    <h4>5.5.1) reduce(): Produces a single value</h4>
    <p>Method Signature : T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : This method performs reduction operation on elements of a stream using initial value and binary operation.</p>

    <pre class="java-code">
<code><span class="class">int</span> sum = <span class="class">Arrays</span>.stream(<span class="keyword">new</span> <span class="class">int</span>[] {<span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>}).reduce(<span class="number">0</span>, (a, b) -> a+b);

<span class="comment">//Output : 32</span></code>
    </pre>

    <p>There is another form of reduce() method which takes no initial value. But returns an Optional object.</p>

    <pre class="java-code">
<code><span class="class">OptionalInt</span> sum = <span class="class">Arrays</span>.stream(<span class="keyword">new</span> <span class="class">int</span>[] {<span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>}).reduce((a, b) -> a+b);

<span class="comment">//Output : OptionalInt[32]</span></code>
    </pre>

    <p>Methods min(), max(), count() and collect() are special cases of reduction operation.</p>

    <h4>5.5.2) min(): Finding the minimum</h4>
    <p>Method Signature : Optional&lt;T&gt; min(Comparator&lt;T&gt; comparator)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : It returns minimum element in a stream wrapped in an Optional object.</p>

    <pre class="java-code">
<code><span class="class">OptionalInt</span> min = <span class="class">Arrays</span>.stream(<span class="keyword">new</span> <span class="class">int</span>[] {<span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>}).min();

<span class="comment">//Output : OptionalInt[1]</span>

<span class="comment">//Here, min() of IntStream will be used as we are passing an array of ints</span></code>
    </pre>

    <h4>5.5.3) max(): Finding the maximum</h4>
    <p>Method Signature : Optional&lt;T&gt; max(Comparator&lt;T&gt; comparator)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : It returns maximum element in a stream wrapped in an Optional object.</p>

    <pre class="java-code">
<code><span class="class">OptionalInt</span> max = <span class="class">Arrays</span>.stream(<span class="keyword">new</span> <span class="class">int</span>[] {<span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>}).max();

<span class="comment">//Output : OptionalInt[9]</span>

<span class="comment">//Here, max() of IntStream will be used as we are passing an array of ints</span></code>
    </pre>

    <h4>5.5.4) count(): Counting the elements</h4>
    <p>Method Signature : long count()</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns the number of elements in a stream.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Counting the names with length > 5</span>
<span class="class">long</span> noOfBigNames = names.stream().filter((<span class="class">String</span> name) -> name.length() > <span class="number">5</span>).count();

System.out.println(noOfBigNames);

<span class="comment">//Output : 3</span></code>
    </pre>

    <h4>5.5.5) collect(): Mutable reduction</h4>
    <p>Method Signature : R collect(Collector&lt;T&gt; collector)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : This method performs mutable reduction operation on elements of a stream. It uses a Collector which encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer) method.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Collecting all names to a list</span>
<span class="class">List</span>&lt;<span class="class">String</span>> namesList = names.stream().collect(<span class="class">Collectors</span>.toList());

System.out.println(namesList);

<span class="comment">//Output : [David, Johnson, Samontika, Brijesh, John]</span></code>
    </pre>

    <h3>5.6) Matching Operations</h3>
    <p>Matching operations are the operations which are used to check whether elements of a stream match a given predicate. These operations return boolean result.</p>

    <h4>5.6.1) anyMatch(): Any one element matches</h4>
    <p>Method Signature : boolean anyMatch(Predicate&lt;T&gt; predicate)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns true if any one element of a stream matches with given predicate.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Whether any name ends with "h"?</span>
<span class="class">boolean</span> anyNameEndsWithH = names.stream().anyMatch(name -> name.endsWith(<span class="string">"h"</span>));

System.out.println(anyNameEndsWithH);

<span class="comment">//Output : true</span></code>
    </pre>

    <h4>5.6.2) allMatch(): All elements match</h4>
    <p>Method Signature : boolean allMatch(Predicate&lt;T&gt; predicate)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns true if all the elements of a stream match with given predicate.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Whether all names have length > 3</span>
<span class="class">boolean</span> allNamesHaveLengthGT3 = names.stream().allMatch(name -> name.length() > <span class="number">3</span>);

System.out.println(allNamesHaveLengthGT3);

<span class="comment">//Output : true</span></code>
    </pre>

    <h4>5.6.3) noneMatch(): No element matches</h4>
    <p>Method Signature : boolean noneMatch(Predicate&lt;T&gt; predicate)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns true only if all the elements of a stream doesn't match with given predicate.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Whether no name ends with "z"?</span>
<span class="class">boolean</span> noNameEndsWithZ = names.stream().noneMatch(name -> name.endsWith(<span class="string">"z"</span>));

System.out.println(noNameEndsWithZ);

<span class="comment">//Output : true</span></code>
    </pre>

    <h3>5.7) Finding Operations</h3>
    <p>Finding operations are the operations which are used to find elements in a stream. These operations return Optional object.</p>

    <h4>5.7.1) findFirst(): Finding the first element</h4>
    <p>Method Signature : Optional&lt;T&gt; findFirst()</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns first element of a stream wrapped in an Optional object.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Finding first name in the list</span>
<span class="class">Optional</span>&lt;<span class="class">String</span>> firstName = names.stream().findFirst();

System.out.println(firstName.get());

<span class="comment">//Output : David</span></code>
    </pre>

    <h4>5.7.2) findAny(): Finding any element</h4>
    <p>Method Signature : Optional&lt;T&gt; findAny()</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Randomly returns any one element in a stream.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Finding any name in the list</span>
<span class="class">Optional</span>&lt;<span class="class">String</span>> anyName = names.stream().findAny();

System.out.println(anyName.get());

<span class="comment">//Output : David (Output may vary)</span></code>
    </pre>

    <h3>5.8) Iterating Operation</h3>

    <h4>5.8.1) forEach(): Iterating the elements</h4>
    <p>Method Signature : void forEach(Consumer&lt;T&gt; action)</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Performs an action on all elements of a stream.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Printing each name in the list</span>
names.stream().forEach(System.out::println);

<span class="comment">// Output :</span>
<span class="comment">// David</span>
<span class="comment">// Johnson</span>
<span class="comment">// Samontika</span>
<span class="comment">// Brijesh</span>
<span class="comment">// John</span></code>
    </pre>

    <h3>5.9) To Array Operation</h3>

    <h4>5.9.1) toArray(): Converting to array</h4>
    <p>Method Signature : Object[] toArray()</p>
    <p>Type Of Operation : Terminal Operation</p>
    <p>What It Does? : Returns an array containing elements of a stream.</p>

    <pre class="java-code">
<code><span class="class">List</span>&lt;<span class="class">String</span>> names = <span class="keyword">new</span> <span class="class">ArrayList</span>&lt;>();
names.add(<span class="string">"David"</span>);
names.add(<span class="string">"Johnson"</span>);
names.add(<span class="string">"Samontika"</span>);
names.add(<span class="string">"Brijesh"</span>);
names.add(<span class="string">"John"</span>);

<span class="comment">//Converting list of names to an array</span>
<span class="class">Object</span>[] namesArray = names.stream().toArray();

System.out.println(<span class="class">Arrays</span>.toString(namesArray));

<span class="comment">//Output : [David, Johnson, Samontika, Brijesh, John]</span></code>
    </pre>

    <h2>6) Specialized Streams</h2>
    <p>In addition to generic Stream&lt;T&gt; interface, Java 8 Streams API provides specialized stream interfaces for working with primitive types - IntStream, LongStream and DoubleStream. These streams contain specialized methods to work with primitive types.</p>

    <h3>6.1) IntStream</h3>
    <p>IntStream is a stream of primitive int values. It contains methods which are specific to int values. For example - sum(), average(), range() etc.</p>

    <pre class="java-code">
<code><span class="comment">//Creating an IntStream</span>
<span class="class">IntStream</span> intStream = <span class="class">IntStream</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);

<span class="comment">//Calculating sum of all elements in IntStream</span>
<span class="class">int</span> sum = intStream.sum();

System.out.println(sum);

<span class="comment">//Output : 15</span></code>
    </pre>

    <h3>6.2) LongStream</h3>
    <p>LongStream is a stream of primitive long values. It contains methods which are specific to long values.</p>

    <pre class="java-code">
<code><span class="comment">//Creating a LongStream</span>
<span class="class">LongStream</span> longStream = <span class="class">LongStream</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);

<span class="comment">//Calculating sum of all elements in LongStream</span>
<span class="class">long</span> sum = longStream.sum();

System.out.println(sum);

<span class="comment">//Output : 15</span></code>
    </pre>

    <h3>6.3) DoubleStream</h3>
    <p>DoubleStream is a stream of primitive double values. It contains methods which are specific to double values.</p>

    <pre class="java-code">
<code><span class="comment">//Creating a DoubleStream</span>
<span class="class">DoubleStream</span> doubleStream = <span class="class">DoubleStream</span>.of(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>);

<span class="comment">//Calculating sum of all elements in DoubleStream</span>
<span class="class">double</span> sum = doubleStream.sum();

System.out.println(sum);

<span class="comment">//Output : 16.5</span></code>
    </pre>

    <h2>7) Conclusion</h2>
    <p>Java 8 Streams API is a powerful API to process the collections of objects. It lets you to write database-like queries on a data source. It supports both sequential and parallel processing of data. It has many operations to filter, map, sort, reduce, find, match and iterate over the elements of a stream. It also provides specialized streams to work with primitive types.</p>
    <p>In this article, we have seen what are streams, why we need them, their characteristics, different types of stream operations with examples. We have also seen specialized streams for primitive types.</p>
    <p>I hope this article has given you a good understanding of Java 8 Streams API. If you have any questions or feedback, please leave a comment below.</p>
    <hr>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../java8/lambda.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../java8/optional.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Footer will be inserted by JavaScript -->

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>