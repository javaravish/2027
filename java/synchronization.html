<!DOCTYPE html>
<html lang="en">
<head>
    <title>Synchronization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="java">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">☰</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="intro.html">Java</a>
        <span class="separator">/</span>
        <a href="#">Synchronization</a>
    </div>
</nav>

<!-- Header will be inserted by JavaScript -->

<!-- Sidebar will be inserted by JavaScript -->

<!-- Main Content Section -->
<main id="content">
    <h2>1. Synchronization</h2>

    <p>In a multithreaded environment, multiple threads may try to modify the same data simultaneously, leading to data
        inconsistency.</p>
    <p>Synchronization in Java is a mechanism to control the access of multiple threads to shared resources. It is
        essential in a multithreaded environment to prevent thread interference and consistency problems.
        Synchronization ensures that only one thread can access the shared resource at a time, thus preserving the
        integrity of the data.</p>

    <h3>How to Use Synchronization in Java?</h3>

    <p>Java provides various mechanisms to handle synchronization:</p>

    <h4>1. Synchronized Method:</h4>

    <p>Synchronize the entire method to ensure only one thread can execute it at a time.</p>

    <pre class="java-code">
  <code>
    <span class="keyword">class</span> <span class="class">Counter</span> {
        <span class="keyword">private</span> <span class="class">int</span> <span class="var">count</span> = <span
          class="number">0</span>;
        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span
          class="class">void</span> <span class="method">increment</span>() {
            <span class="var">count</span>++;
        }
        <span class="keyword">public</span> <span class="class">int</span> <span class="method">getCount</span>() {
            <span class="keyword">return</span> <span class="var">count</span>;
        }
    }
  </code>
</pre>

    <h4>2. Synchronized Block:</h4>

    <p>Synchronize a block of code instead of the entire method, providing more control and efficiency.</p>

    <pre class="java-code">
  <code>
    <span class="keyword">class</span> <span class="class">Counter</span> {
        <span class="keyword">private</span> <span class="class">int</span> <span class="var">count</span> = <span
          class="number">0</span>;
        <span class="keyword">public</span> <span class="class">void</span> <span class="method">increment</span>() {
            <span class="keyword">synchronized</span> (<span class="var">this</span>) {
                <span class="var">count</span>++;
            }
        }
        <span class="keyword">public</span> <span class="class">int</span> <span class="method">getCount</span>() {
            <span class="keyword">return</span> <span class="var">count</span>;
        }
    }
  </code>
</pre>

    <h4>3. Static Synchronization:</h4>

    <p>Synchronize static methods to ensure only one thread can execute them for the class, not the instance.</p>

    <pre class="java-code">
  <code>
    <span class="keyword">class</span> <span class="class">Counter</span> {
        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class">int</span> <span
          class="var">count</span> = <span class="number">0</span>;
        <span class="keyword">public</span> <span class="keyword">static</span> <span
          class="keyword">synchronized</span> <span class="class">void</span> <span class="method">increment</span>() {
            <span class="var">count</span>++;
        }
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class">int</span> <span
          class="method">getCount</span>() {
            <span class="keyword">return</span> <span class="var">count</span>;
        }
    }
  </code>
</pre>

    <h4>4. Locks:</h4>

    <p>Use <code>java.util.concurrent.locks.Lock</code> for more sophisticated thread synchronization.</p>

    <pre class="java-code">
  <code>
    <span class="keyword">import</span> <span class="namespace">java.util.concurrent.locks.Lock</span>;
    <span class="keyword">import</span> <span class="namespace">java.util.concurrent.locks.ReentrantLock</span>;
    <span class="keyword">class</span> <span class="class">Counter</span> {
        <span class="keyword">private</span> <span class="class">int</span> <span class="var">count</span> = <span
          class="number">0</span>;
        <span class="keyword">private</span> <span class="keyword">final</span> <span class="class">Lock</span> <span
          class="var">lock</span> = <span class="keyword">new</span> <span class="class">ReentrantLock</span>();
        <span class="keyword">public</span> <span class="class">void</span> <span class="method">increment</span>() {
            <span class="var">lock</span>.<span class="method">lock</span>();
            <span class="keyword">try</span> {
                <span class="var">count</span>++;
            } <span class="keyword">finally</span> {
                <span class="var">lock</span>.<span class="method">unlock</span>();
            }
        }
        <span class="keyword">public</span> <span class="class">int</span> <span class="method">getCount</span>() {
            <span class="keyword">return</span> <span class="var">count</span>;
        }
    }
  </code>
</pre>

    <h4>Example: Synchronized Method</h4>

    <h3>Deadlock in Java</h3>

    <p>Deadlock occurs when two or more threads are blocked forever, waiting for each other. Deadlocks are a significant
        issue in concurrent programming and can lead to application freeze.</p>

    <h4>Example of Deadlock</h4>

    <pre class="java-code">
  <code>
    <span class="keyword">class</span> <span class="class">Resource</span> {
        <span class="keyword">synchronized</span> <span class="class">void</span> <span
          class="method">method1</span>(<span class="class">Resource</span> <span class="var">r</span>) {
            <span class="class">System</span>.<span class="var">out</span>.<span class="method">println</span>(<span
          class="class">Thread</span>.<span class="method">currentThread</span>().<span class="method">getName</span>() + <span
          class="string">" is executing method1"</span>);
            <span class="keyword">try</span> { <span class="class">Thread</span>.<span class="method">sleep</span>(<span
          class="number">100</span>); } <span class="keyword">catch</span> (<span
          class="class">InterruptedException</span> <span class="var">e</span>) {}
            <span class="var">r</span>.<span class="method">method2</span>(<span class="var">this</span>);
        }

        <span class="keyword">synchronized</span> <span class="class">void</span> <span
          class="method">method2</span>(<span class="class">Resource</span> <span class="var">r</span>) {
            <span class="class">System</span>.<span class="var">out</span>.<span class="method">println</span>(<span
          class="class">Thread</span>.<span class="method">currentThread</span>().<span class="method">getName</span>() + <span
          class="string">" is executing method2"</span>);
            <span class="keyword">try</span> { <span class="class">Thread</span>.<span class="method">sleep</span>(<span
          class="number">100</span>); } <span class="keyword">catch</span> (<span
          class="class">InterruptedException</span> <span class="var">e</span>) {}
            <span class="var">r</span>.<span class="method">method1</span>(<span class="var">this</span>);
        }
    }

    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class">DeadlockExample</span> {
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class">void</span> <span
          class="method">main</span>(<span class="class">String</span>[] <span class="var">args</span>) {
            <span class="keyword">final</span> <span class="class">Resource</span> <span class="var">r1</span> = <span
          class="keyword">new</span> <span class="class">Resource</span>();
            <span class="keyword">final</span> <span class="class">Resource</span> <span class="var">r2</span> = <span
          class="keyword">new</span> <span class="class">Resource</span>();
            <span class="class">Thread</span> <span class="var">t1</span> = <span class="keyword">new</span> <span
          class="class">Thread</span>(() -> <span class="var">r1</span>.<span class="method">method1</span>(<span
          class="var">r2</span>), <span class="string">"Thread-1"</span>);
            <span class="class">Thread</span> <span class="var">t2</span> = <span class="keyword">new</span> <span
          class="class">Thread</span>(() -> <span class="var">r2</span>.<span class="method">method1</span>(<span
          class="var">r1</span>), <span class="string">"Thread-2"</span>);
            <span class="var">t1</span>.<span class="method">start</span>();
            <span class="var">t2</span>.<span class="method">start</span>();
        }
    }
  </code>
</pre>

    <h4>Explanation:</h4>

    <p>1. Resource Class: Contains two synchronized methods <code>method1</code> and <code>method2</code> which call
        each other.</p>
    <p>2. Deadlock Scenario:</p>
    <p>— <code>Thread-1</code> locks <code>r1</code> and waits for <code>r2</code>.</p>
    <p>— <code>Thread-2</code> locks <code>r2</code> and waits for <code>r1</code>.</p>
    <p>3. Result: Both threads are blocked forever, causing a deadlock.</p>

    <h4>Avoiding Deadlocks</h4>

    <p>To avoid deadlocks, follow these practices:</p>
    <p>1. Lock Ordering: Ensure all threads acquire locks in the same order.</p>
    <p>2. Lock Timeout: Use <code>tryLock</code> with a timeout.</p>
    <p>3. Avoid Nested Locks: Reduce or avoid nested locks.</p>

    <h3>10 Points-To-Remember About Synchronization</h3>

    <p>1. You can use synchronized keyword only with methods but not with variables, constructors, static initializer
        and instance initializers.</p>
    <p>2. Constructors, Static initializer and instance initializer can't be declared with synchronized keyword, but
        they can contain synchronized blocks.</p>
    <p>3. Both static and non-static methods can use synchronized keyword. For static methods, thread need class level
        lock and for non-static methods, thread need object level lock.</p>
    <p>4. It is possible that both static synchronized and non-static synchronized methods can run simultaneously.
        Because, static methods need class level lock and non-static methods need object level lock.</p>
    <p>5. A method can contain any number of synchronized blocks. This is like synchronizing multiple parts of a
        method.</p>
    <p>6. Synchronization blocks can be nested.</p>
    <p>7. Lock acquired by the thread before executing a synchronized method or block must be released after the
        completion of execution, no matter whether execution is completed normally or abnormally (due to
        exceptions).</p>
    <p>8. Synchronization in java is <strong>Re-entrant in nature</strong>. A thread can not acquire a lock that is
        owned by another thread. But, a thread can acquire a lock that it already owns. That means if a synchronized
        method gives a call to another synchronized method which needs same lock, then currently executing thread can
        directly enter into that method or block without acquiring the lock.</p>
    <p>9. synchronized method or block is very slow. They decrease the performance of an application. So, special care
        need to be taken while using synchronization. Use synchronization only when you needed it the most.</p>
    <p>10. Use synchronized blocks instead of synchronized methods. Because, synchronizing some part of a method
        improves the performance than synchronizing the whole method.</p>

    <h3>Inter-thread Communication in Java</h3>

    <p>Inter-thread Communication in Java allows synchronized threads to communicate with each other. Java provides
        <code>wait()</code>, <code>notify()</code>, and <code>notifyAll()</code> methods to facilitate this
        communication.</p>

    <h4>Example of Inter-thread Communication</h4>

    <pre class="java-code">
  <code>
    <span class="keyword">class</span> <span class="class">SharedResource</span> {
        <span class="keyword">private</span> <span class="class">boolean</span> <span class="var">ready</span> = <span
          class="keyword">false</span>;
        <span class="keyword">synchronized</span> <span class="class">void</span> <span class="method">produce</span>() {
            <span class="keyword">try</span> {
                <span class="keyword">while</span> (<span class="var">ready</span>) {
                    <span class="method">wait</span>();
                }
                <span class="class">System</span>.<span class="var">out</span>.<span class="method">println</span>(<span
          class="string">"Producing..."</span>);
                <span class="var">ready</span> = <span class="keyword">true</span>;
                <span class="method">notify</span>();
            } <span class="keyword">catch</span> (<span class="class">InterruptedException</span> <span
          class="var">e</span>) {
                <span class="var">e</span>.<span class="method">printStackTrace</span>();
            }
        }
        <span class="keyword">synchronized</span> <span class="class">void</span> <span class="method">consume</span>() {
            <span class="keyword">try</span> {
                <span class="keyword">while</span> (!<span class="var">ready</span>) {
                    <span class="method">wait</span>();
                }
                <span class="class">System</span>.<span class="var">out</span>.<span class="method">println</span>(<span
          class="string">"Consuming..."</span>);
                <span class="var">ready</span> = <span class="keyword">false</span>;
                <span class="method">notify</span>();
            } <span class="keyword">catch</span> (<span class="class">InterruptedException</span> <span
          class="var">e</span>) {
                <span class="var">e</span>.<span class="method">printStackTrace</span>();
            }
        }
    }

    <span class="keyword">public</span> <span class="keyword">class</span> <span class="class">InterThreadCommunicationExample</span> {
        <span class="keyword">public</span> <span class="keyword">static</span> <span class="class">void</span> <span
          class="method">main</span>(<span class="class">String</span>[] <span class="var">args</span>) {
            <span class="class">SharedResource</span> <span class="var">resource</span> = <span
          class="keyword">new</span> <span class="class">SharedResource</span>();
            <span class="class">Thread</span> <span class="var">producer</span> = <span class="keyword">new</span> <span
          class="class">Thread</span>(<span class="var">resource</span>::<span class="method">produce</span>);
            <span class="class">Thread</span> <span class="var">consumer</span> = <span class="keyword">new</span> <span
          class="class">Thread</span>(<span class="var">resource</span>::<span class="method">consume</span>);
            <span class="var">producer</span>.<span class="method">start</span>();
            <span class="var">consumer</span>.<span class="method">start</span>();
        }
    }
  </code>
</pre>
    <p>This code demonstrates inter-thread communication in Java using a shared resource. It includes two main
        operations: producing and consuming. These operations are synchronized to ensure proper coordination between
        threads.</p>
    <hr>
    <h2>2. Break Singleton pattern</h2>

    <p>The singleton design pattern in Java aims to ensure that a class has only one instance and provides a global
        point of access to it. However, there are several ways to break this pattern and create multiple instances of a
        singleton class. Let's explore the common ways and how to prevent them:</p>

    <h3>1. Using Reflection</h3>

    <p>The Java Reflection API allows inspecting and manipulating classes, methods, and fields at runtime. It can be
        used to bypass access control checks and create new instances of a singleton class by accessing its private
        constructor. An example demonstrating this can be found in the referenced documents. To prevent this, you can
        modify the singleton constructor to throw an exception if an instance already exists, or use an enum to
        implement the singleton pattern, as enums are inherently protected against reflection.</p>

    <h3>2. Serialization and Deserialization</h3>

    <p>Serialization converts an object to a byte stream, and deserialization converts it back. Deserializing a
        serialized singleton object can create a new instance, breaking the pattern. An example of this can be found in
        the referenced documents. To prevent this, override the <code>readResolve()</code> method in the singleton class
        to return the existing instance during deserialization.</p>

    <h3>3. Cloning</h3>

    <p>The <code>clone()</code> method can create a copy of an object, potentially leading to multiple singleton
        instances. An example of breaking using cloning is provided in the referenced documents. To prevent this,
        override the <code>clone()</code> method to either throw a <code>CloneNotSupportedException</code> or return the
        existing singleton instance.</p>

    <h3>4. Multiple Classloaders</h3>

    <p>If different classloaders load the same singleton class, each can create its own instance. This can be prevented
        by ensuring the singleton is loaded by a common parent classloader, such as by placing it in the boot classpath
        or a shared library directory.</p>

    <h3>5. Threading Issues (Double-Checked Locking)</h3>

    <p>In a multi-threaded environment, improper synchronization during lazy initialization can result in multiple
        singleton instances. This can be prevented by using double-checked locking, which involves synchronizing the
        instance creation block and checking for the instance being null twice for performance optimization.
        Alternatively, using an enum singleton is inherently thread-safe and avoids these issues.</p>

    <p>By being aware of these potential breaking mechanisms and employing the suggested preventive measures, you can
        ensure the robustness and integrity of your singleton implementations in Java.</p>
    <hr>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../java/serialization.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../java/comparable_comparator.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Footer will be inserted by JavaScript -->

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>