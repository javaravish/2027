<!DOCTYPE html>
<html lang="en">
<head>
    <title>Serialization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../js/styles.css"/>
</head>
<body data-sidebar="java">
<nav>
    <button class="mobile-sidebar-btn" id="mobileSidebarBtn">☰</button>
    <div class="breadcrumbs">
        <a href="../home.html">Home</a>
        <span class="separator">/</span>
        <a href="intro.html">Java</a>
        <span class="separator">/</span>
        <a href="#">Serialization</a>
    </div>
</nav>

<!-- Header will be inserted by JavaScript -->

<!-- Sidebar will be inserted by JavaScript -->

<!-- Main Content Section -->
<main id="content">
    <h2>1. Serialization</h2>
    <p>Serialization in Java is the process of converting the state of a Java object into a byte stream. This byte
        stream can then be stored in a file, transmitted over a network, or saved in a database, allowing for object
        persistence and data transfer.</p>

    <p><strong>Key aspects of Java serialization:</strong></p>
    <p>- <strong>Serializable</strong> Interface:<br>
        To make a class's objects serializable, the class must implement the java.io.Serializable marker interface. This
        interface does not contain any methods but acts as a signal to the Java Virtual Machine (JVM) that objects of
        this class can be serialized.</p>

    <p>- <strong>ObjectOutputStream</strong>:<br>
        This class is used to write Java objects to an output stream in a serialized format. Its writeObject() method
        takes an object and converts it into a byte stream.</p>

    <p>- <strong>serialVersionUID</strong>:<br>
        This static final long field is recommended for Serializable classes. It serves as a version control mechanism
        during deserialization to ensure compatibility between the serialized object and the class definition used for
        deserialization. If the serialVersionUID values do not match, an InvalidClassException is thrown. It is good
        practice to declare a <code>serialVersionUID</code> for a <code>Serializable</code> class. This ID is used
        during deserialization to verify that the sender and receiver of a serialized object have loaded classes for
        that object that are compatible with respect to serialization.</p>

    <p><strong>transient Keyword:</strong></p>
    <p>Fields marked with the transient keyword are excluded from the serialization process, meaning their values will
        not be saved when the object is serialized.Fields that are marked as 'transient' are not serialized. This is
        useful for sensitive data or data that can be derived from other fields.</p>

    <p>Deserialization, conversely, is the process of converting a byte stream back into a Java object in memory.</p>

    <pre class="java-code">
        <code>
<span class="keyword">public class</span> <span class="class">SerializeExample</span> {
    <span class="keyword">public static</span> <span class="class">void</span> <span class="method">main</span>(<span
                class="class">String</span>[] args) {
        <span class="class">Employee</span> emp = <span class="keyword">new</span> <span
                class="class">Employee</span>(<span class="string">"John Doe"</span>, 101, 50000.0);
        <span class="keyword">try</span> (<span class="class">FileOutputStream</span> fileOut = <span class="keyword">new</span> <span
                class="class">FileOutputStream</span>(<span class="string">"employee.ser"</span>);
             <span class="class">ObjectOutputStream</span> out = <span class="keyword">new</span> <span class="class">ObjectOutputStream</span>(fileOut)) {
            out.writeObject(emp);
            <span class="class">System</span>.out.println(<span class="string">"Serialized data is saved in employee.ser"</span>);
        } <span class="keyword">catch</span> (<span class="class">IOException</span> i) {
            i.printStackTrace();
        }
    }
}
        </code>
    </pre>

    <p><strong>Key aspects of Java deserialization:</strong></p>
    <p><strong>ObjectInputStream:</strong></p>
    <p>This class is used to read serialized Java objects from an input stream. Its readObject() method reads the byte
        stream and reconstructs the original object.</p>

    <p><strong>Constructor Bypassing:</strong></p>
    <p>During deserialization, Java deliberately bypasses the object's constructors to ensure that the object's state is
        restored exactly as it was when serialized, without any additional initialization logic or side effects from a
        constructor being invoked.</p>

    <pre class="java-code">
        <code>
<span class="keyword">public class</span> <span class="class">DeserializeExample</span> {
    <span class="keyword">public static</span> <span class="class">void</span> <span class="method">main</span>(<span
                class="class">String</span>[] args) {
        <span class="class">Employee</span> emp = <span class="keyword">null</span>;
        <span class="keyword">try</span> (<span class="class">FileInputStream</span> fileIn = <span
                class="keyword">new</span> <span class="class">FileInputStream</span>(<span class="string">"employee.ser"</span>);
             <span class="class">ObjectInputStream</span> in = <span class="keyword">new</span> <span class="class">ObjectInputStream</span>(fileIn)) {
            emp = (<span class="class">Employee</span>) in.readObject();
            <span class="class">System</span>.out.println(<span class="string">"Deserialized Employee..."</span>);
            <span class="class">System</span>.out.println(<span class="string">"Name: "</span> + emp.getName());
            <span class="class">System</span>.out.println(<span class="string">"ID: "</span> + emp.getId());
            <span class="class">System</span>.out.println(<span class="string">"Salary: "</span> + emp.getSalary());
        } <span class="keyword">catch</span> (<span class="class">IOException</span> | <span class="class">ClassNotFoundException</span> e) {
            e.printStackTrace();
        }
    }
}
        </code>
    </pre>

    <p>In summary:</p>
    <p>• Serialization: Object to byte stream (for storage or transmission).</p>
    <p>• Deserialization: Byte stream to object (for reconstruction).</p>
    <p>These processes are fundamental for tasks such as saving and restoring application states, inter-process
        communication, and object persistence in various Java applications and frameworks.</p>
    <hr>
    <h2>2. Externalization</h2>
    <p>Externalization in Java is a mechanism that allows developers to have complete control over the serialization
        process. It is implemented using the Externalizable interface, which requires defining the writeExternal() and
        readExternal() methods. Unlike default serialization, externalization enables selective serialization of object
        fields, improving efficiency. This approach is useful for optimizing performance in applications dealing with
        large objects.</p>

    <p><strong>Key aspects of Externalization:</strong></p>
    <p>• <strong>Externalizable Interface:</strong></p>
    <p>To implement externalization, a class must implement the java.io.Externalizable interface. This interface extends
        Serializable and requires the implementation of two methods:</p>
    <p>• void writeExternal(ObjectOutput out) throws IOException:</p>
    <p>This method is responsible for writing the object's state to the ObjectOutput stream.</p>
    <p>• void readExternal(ObjectInput in) throws IOException, ClassNotFoundException: This method is responsible for
        reading the object's state from the ObjectInput stream and reconstructing the object.</p>

    <p>• <strong>Explicit Control:</strong></p>
    <p>Unlike Serializable, where the JVM automatically handles the serialization process, Externalizable gives the
        programmer complete control. Developers decide which fields to serialize, how they are written, and how they are
        read back, allowing for custom logic, optimization, and handling of sensitive data.</p>

    <p>• <strong>No-argument Constructor:</strong></p>
    <p>A class implementing Externalizable must have a public no-argument constructor. This is because the
        deserialization process uses this constructor to create an instance of the class before calling readExternal()
        to populate its state.</p>

    <p><strong>Use Cases:</strong></p>
    <p>* <strong>Performance Optimization:</strong> By selectively serializing only necessary fields, externalization
        can reduce the size of serialized objects and improve serialization/deserialization performance, especially for
        objects with many fields or large data.</p>
    <p>* <strong>Security:</strong> Sensitive data can be excluded or encrypted during serialization.</p>
    <p>* <strong>Version Compatibility:</strong> Developers can implement custom logic to handle changes in object
        structure across different versions, ensuring backward or forward compatibility.</p>

    <pre class="java-code">
        <code>
<span class="keyword">public class</span> <span class="class">MyExternalizableClass</span> <span class="keyword">implements</span> <span
                class="class">Externalizable</span> {
    <span class="keyword">private</span> <span class="class">String</span> name;
    <span class="keyword">private</span> <span class="class">int</span> id;
    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="class">String</span> password; <span
                class="comment">// This field will not be automatically serialized</span>

    <span class="comment">// Public no-argument constructor is required for Externalizable</span>
    <span class="keyword">public</span> <span class="class">MyExternalizableClass</span>() {
        <span class="comment">// Optional initialization</span>
    }

    <span class="keyword">public</span> <span class="class">MyExternalizableClass</span>(<span
                class="class">String</span> name, <span class="class">int</span> id, <span class="class">String</span> password) {
        <span class="keyword">this</span>.name = name;
        <span class="keyword">this</span>.id = id;
        <span class="keyword">this</span>.password = password;
    }

    @Override
    <span class="keyword">public</span> <span class="class">void</span> <span class="method">writeExternal</span>(<span
                class="class">ObjectOutput</span> out) <span class="keyword">throws</span> <span class="class">IOException</span> {
        out.writeUTF(name); <span class="comment">// Write the name</span>
        out.writeInt(id); <span class="comment">// Write the ID</span>
        <span class="comment">// We choose not to write the 'password' field for security</span>
    }

    @Override
    <span class="keyword">public</span> <span class="class">void</span> <span class="method">readExternal</span>(<span
                class="class">ObjectInput</span> in) <span class="keyword">throws</span> <span
                class="class">IOException</span>, <span class="class">ClassNotFoundException</span> {
        <span class="keyword">this</span>.name = in.readUTF(); <span class="comment">// Read the name</span>
        <span class="keyword">this</span>.id = in.readInt(); <span class="comment">// Read the ID</span>
        <span class="comment">// The 'password' field is not read as it was not written</span>
    }

    <span class="comment">// Getters and Setters (omitted for brevity)</span>
}
        </code>
    </pre>

    <h3>Difference Between Serialization and Externalization in Java</h3>
    <div class="table-container">
        <table class="basic-table">
            <thead>
            <tr>
                <th>Parameters</th>
                <th>Serialization</th>
                <th>Externalization</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Interface</td>
                <td>Implements Serializable</td>
                <td>Implements Externalizable</td>
            </tr>
            <tr>
                <td>Control</td>
                <td>Java manages serialization</td>
                <td>Developer defines how to serialize and deserialize objects</td>
            </tr>
            <tr>
                <td>Performance</td>
                <td>Can be slow due to default behavior</td>
                <td>Faster if optimized correctly</td>
            </tr>
            <tr>
                <td>Methods</td>
                <td>No methods required</td>
                <td>Requires writeExternal() and readExternal()</td>
            </tr>
            <tr>
                <td>Customization</td>
                <td>Limited customization</td>
                <td>Complete control over serialization process</td>
            </tr>
            </tbody>
        </table>
    </div>

    <p><strong>Features of Externalization</strong></p>
    <p>1. <strong>Full Control:</strong> The developer decides which fields are serialized.</p>
    <p>2. <strong>Efficient Storage:</strong> Reduces unnecessary data storage, optimizing performance.</p>
    <p>3. <strong>Security:</strong> Sensitive fields can be excluded from serialization.</p>
    <p>4. <strong>Backward Compatibility:</strong> Externalization allows modifications without affecting existing
        serialized objects.</p>
    <hr>
    <div class="card-footer">
        <ul class="pagination justify-content-center">
            <li class="page-item"><a class="page-link btn-outline-primary"
                                     href="../java/multithreading.html">&lArr; Previous</a></li>
            <li class="page-item"><a class="page-link" href="../java/synchronization.html">Next
                &rArr;</a></li>
        </ul>
    </div>
</main>

<!-- Footer will be inserted by JavaScript -->

<!-- Scripts -->
<script src="../js/sidebar.js"></script>
<script src="../js/componentLoader.js"></script>
</body>
</html>